<!--

Syntax: https://kramdown.gettalong.org/syntax.html

Don't change any headers without checking for links.

TODOs:

Change all Word's directional double-quotes to ".  Kramdown changes them back again anyway.

Look for — (which is not -).  Or leave them be, because they look like proper em-dashes in HTML,
better than --.  Kramdown changes -- and --- to en- and em-dashes resp. so might as well make this
file ASCII-clean.

Newer screenshots.  They are a bit out of date, and low-res.

-->

# Work in progress:  Command Centre REST API training material
{:.no_toc}

This document will be a markdown port of a document used internally at Gallagher Group to train
developers in the use of Command Centre's REST API.  This version is not yet suitable for
publication, but if you are using the REST API and like the sound of 60-odd more pages of reading
material, please contact Gallagher through your channel partner and talk to our Technical Support
Engineers about your project.

## Disclaimer
{:.no_toc}

This document gives certain information about products and/or services provided by Gallagher Group
Limited or its related companies (referred to as "Gallagher Group").

The information is indicative only and is subject to change without notice meaning it may be out of
date at any given time.  Although every commercially reasonable effort has been taken to ensure the
quality and accuracy of the information, Gallagher Group makes no representation as to its accuracy
or completeness and it should not be relied on as such.  To the extent permitted by law, all express
or implied, or other representations or warranties in relation to the information are expressly
excluded.

Neither Gallagher Group nor any of its directors, employees or other representatives shall be
responsible for any loss that you may incur, either directly or indirectly, arising from any use or
decisions based on the information provided.

Except where stated otherwise, the information is subject to copyright owned by Gallagher Group and
you may not sell it without permission.  Gallagher Group is the owner of all trademarks reproduced
in this information.  All trademarks which are not the property of Gallagher Group, are
acknowledged.

Copyright © Gallagher Group Ltd 2021.  All rights reserved.

Gallagher Group Limited  
PO Box 3026  
Hamilton  
New Zealand  
+64 (7) 838 9800   
E-Mail: sales.nz@security.gallagher.com  
Website: www.gallagher.com  

# Table of contents
{:.no_toc}

<!-- This auto-generated ToC is generated by github pages (Jekyll, Kramdown, Maruku) so is not
visible when you look at the README.MD in github.com.  Also, it is huge.  Bigger than is necessary.
But despite those two disadvantages, I'm going to stick with it for now because it's easier than
manually adding a row here for each new section. -->

1. The ToC is generated by github pages (Jekyll, Kramdown, Maruku).  If you're seeing this, it's
  because you're reading the README.md on github.com instead of https://gallaghersecurity.github.io .
{:toc}

<!-- {::options toc_levels="2" syntax_highlighter_opts="{line_numbers: true}" } -->

<!-- Manual ToC

1. [References](#references):  API reference, user manuals, and sample code.

2. [Training Setup](#training-setup):  what you will need to try the API.

1. [Useful background](#useful-background):  an introduction to Command Centre for people who are
   new to physical access control systems or REST.

   [Cardholders](#cardholders),
   [Operators and operator groups](#operators-and-operator-groups),
   [Access groups](#access-groups),
   [Personal data fields (PDFs)](#personal-data-fields-pdfs),
   [Divisions](#divisions),
   [Roles](#roles), [Competencies](#competencies),
   [Card types](#card-types),
   [Items](#all-the-above-are-items),
   [Events and alarms](#events-and-alarms),
   [Operator privileges](#operator-privileges),
   [HTTP requests](#http-requests) (GET, POST, PATCH, DELETE, headers, and bodies),
   [JSON](#json).
   
2. [Set up Command Centre](#set-up-command-centre)
      1. [Turn on the web server](#turn-on-the-web-server)
      3. [Create a REST operator](#create-a-rest-operator)
      3. [Create a REST Client item](#create-a-rest-client-item)
      3. [What is an API key?](#what-is-an-api-key)
      
5. [Try the sample client application](#try-the-sample-client-application)

2. [Set up Chrome](#set-up-chrome):  install the ModHeader extension and a JSON pretty-printer, and
   don't mind if the server certificate is bad.
   
2. [Set up Postman](#set-up-postman):  send the API header, set the content type, and don't mind if
   the server certificate is bad.
   
2. [First GETs:  cardholders](#first-gets--cardholders):  get the API's contents page, get all
   cardholders, get one cardholder.
   
9. [First GETs:  events](#first-gets--events):  list all events, list all alarms.

2. [Back into the theory](#back-into-the-theory):  API controllers, why we need operators, the
   request process.
   
11. [First POST and search](#first-post-and-search):  create a cardholder and search for it.

2. [Cardholder flat fields](#cardholder-flat-fields):  give a cardholder access groups and PDFs,
   changing simple fields, images.
   
13. [Cards](#cards):  adding, updating, and (not!) deleting.

14. [Group memberships](#group-memberships)

15. [Create a cardholder, cont.](#create-a-cardholder-cont)  

2. [Coding considerations](#coding-considerations)  
   Recap.  
   Only one cardholder at a time.  
   The importance of `/api`.  
   Identifiers in your app.  
   Do not build your own hrefs from ID.  
   Sort by ID, and get all summary pages before any details.  
   Monitoring for cardholder changes is much better in 8.30.  
   Long polls.  
   Benchmarks.
   
2. [Advanced events](#advanced-events)  
   Event filters
   IDs to use in them.  
   Filtering by date.  
   Adding PDF values (like staff IDs) to the cardholders in events.  
   Writing an interactive event viewer.  
   Worked example:  reading alarms.
   
18. [Client-side certificates](#client-side-certificates)

19. [Server-side certificates](#server-side-certificates)

20. [Other Command Centre items](#other-command-centre-items)

21. [Appendix:  privilege table](#appendix--privilege-table)

2. [Appendix:  features and licences](#appendix--features-and-licences)

-->


-------------------------------------------------------------------------

# Introduction

DRAFT DO NOT DISTRIBUTE.

This document is an introduction to using the REST API in Command Centre, aimed at those involved in
the development of software that will integrate Command Centre into other solutions.  It was written
to accompany an informal education session with a Gallagher trainer.

It covers features first released in 7.80 and expanded in 7.90.

It uses the following styles for guided examples:

`Fixed-width fonts` indicate filenames, parts of URLs, and text that benefits from vertical
alignment.

<pre>
Indented fixed-width blocks are client requests that you can copy out for your own work (values
you should change are in <i>italics</i>) and server responses, pretty-printed a little to make them
readable.
</pre>

> **Special notes** use Markdown's type of quoting, like this.

~~~javascript
// another option I'm considering
// GET /api
{
    "a text field": "string", // comments look okay
    "a numeric field": 1234,
    "a Boolean field": false
}
~~~

## Exclusions

This document does not cover special handling of PIV cards.  It shows how to create a generic card
and leaves the variations for PIV and PIV-I to the developer documentation.

Nor does it cover some of the features added after v7.90:  access zones, alarm zones, fence zones,
doors, outputs, inputs, PDF definitions, macros, changing cardholder zones, operators, visitors,
schedules, and subscribing to cardholder updates.

-------------------------------------------------------------------------

# References

This document refers to API documentation, online help, and sample code.  All are on the Command
Centre ISO (or DVD, if you have physical media).

## Developer API documentation
https://gallaghersecurity.github.io/ holds the reference API documentation.  That is the primary
reference for the REST API, so it aims to be complete, and you should have it on hand whenever
developing against Command Centre.  However the amount of detail can be daunting and it is not very
introductory, which is why this document exists.

We are always improving the content so it is best read online, but if you need an offline copy you
can either download a ZIP from https://github.com/GallagherSecurity/cc-rest-docs, or take a copy
from Utilities/REST API/REST Documentation*/ in the ISO.  Beware, however, that the copy on the DVD
lags the online version by weeks or months.

It comprises five HTML files:
* index.html gives links to the other four;
* cardholders.html describes the cardholder API calls and supporting concepts, such as card types,
  access groups, PDFs, roles, and competencies.  These functions were new to 7.90.  8.30 added a
  cardholder change-tracking API;
* piv.html covers the additional fields you supply and see on PIV and PIV-I cards;
* events.html covers the alarms and events calls.  This is all that was available in 7.80.  8.10
  added the ability to create your own events;
* rest.html covers Command Centre items that are not cardholders, alarms, or events:  alarm zones,
  access zones, fence zones, outputs, doors, and macros arrived in 8.00, and inputs in 8.10.  8.30
  added a way to mass-monitor items.

If running on Windows, something in the mix of Internet Explorer, Javascript, and file: URLs on
network shares prevents the HTML rendering properly so if those files look goofy to you, try a
different browser or copy the folder to your local drive.  Or read it online.

## Online help and other documents

The Configuration Client's Help menu opens a CHM file that you can also find in the ISO at
`Setup\Program Files\Gallagher\Command Centre\Bin\Resources\en`.  There is a PDF version, split into
three volumes, on the ISO in the Documentation folder.

The Command Centre hardening guide, also on the ISO, is required reading for security-conscious
sites.  While you may not be able to follow its leading advice regarding the REST API ('leave it
turned off') there is plenty more in there to be aware of.

If you are interested in the security of the REST API, look in [the request
process](#the-request-process) for how the server authenticates and authorises requests in general,
and [client-side certificates](#client-side-certificates) for how it authenticates clients using
certificates.

## Sample code
See `Utilities/REST API/REST API Sample Code.zip` in the Command Centre ISO.  There is a WPF client
in there and a console application in a C# Visual Studio solution.

[devdocslong]: https://gallaghersecurity.github.io/ "Developer reference documentation on Github.io"
[devdocs]: .. "Developer reference documentation on Github.io"

## Abbreviations

Visible at github.com, integrated into hover text at gallaghersecurity.github.io .

*[PDF]: Personal Data Field.  Not Adobe's kind of PDF

*[CC]: Command Centre


----------------------------------------------------------------------

# Training setup

If you wish to try the REST API for yourself, you will require:

* Command Centre 7.90 or later with a RESTCardholders licence, a RESTEvents licence if you are to
  examine events, RESTStatus if you are to look at site items, RESTOverrides if you want to override
  them, and RESTCreateEvents if you wish to create events.  This document does not cover the last
  three.
* A host capable of reaching port 8904 on Command Centre via HTTPS, or desktop access to the CC
  server itself.
* (Recommended) the sample REST client application from the Command Centre installation media (8.10
  onward).
* (Optional) the [Postman](https://postman.com) installer, or access to it on the internet.
* (Optional) Chrome and access to the internet for two extensions.
* (Optional) wget or curl.
* The [API developer documentation][devdocs].

<!--
#####################################################################################
Some people come to the API without knowing anything about CC.  Or even HTTP.
#####################################################################################
-->

----------------------------------------------------------------------

# Useful background

This section contains material you should have aboard before reading on.  Skip it if you are
familiar with CC.



## Cardholders
Cardholders are user accounts.  Depending on what you give a cardholder account it can suit
different purposes:

* people with cards and access needs, but no administrative responsibilities.  The REST API allows
  management of these kinds of cardholders;
* administrative people with all that plus the rights to configure the system and manage its users.
  8.50 added features for managing these kinds of cardholders;
* system accounts with no person associated and no physical access, but administrative access to the
  system.  You are about to create one of these.

## Operators and operator groups
Operators are cardholders with benefits.  They become operators through membership of one or more
operator groups.  An operator group bestows privileges on its members, including the ability to log
in to the Command Centre thick clients or run REST queries.

Operator groups have no effect on access control, so they do not appear in this document again
except when [creating an operator](#create-a-rest-operator) which puts a cardholder in an operator
group while setting up a REST client.  Operator groups came to the API in 8.50.

## Access groups
Cardholders can be members of any number of access groups.  An access group can be a member of one
other—its parent.  Command Centre considers a member of a group to be a member of all the groups up
its parenting line, as you would expect.

A cardholder must be a member of an access group before he or she can open a door, so every
cardholder that represents a person should have group memberships.  (Footnote:  there are exceptions
of course.  Some visitors, for example, do not need to open doors, but they exist in CC so that it
can record their location as they move around the site with their host.)

A cardholder can have many memberships of the same group.  This is useful because each has its own
start and end times.  Past memberships fade away.

Access groups are not operator groups.  When this document refers to a group it means an access
group.

A cardholder must be a member of an access group before he or she can have personal data, next.

## Personal data fields (PDFs)

A Personal Data Field is an item that adds a custom value to a cardholder.  Each PDF has a type
(text, image, numeric, date, telephone number, email address...) and optional constraints on the
values that it can hold.  For example, text, email, and telephone number types can have a regular
expression attached which a new value must match before Command Centre will accept it.  A date can
have a maximum and a minimum.  Text PDFs can have a list of valid values, like an enumeration.

There is more configuration:  image PDFs have a type and size, to which Command Centre will
transcode incoming images.  Mobile numbers and email addresses have a flag indicating whether they
are suitable to receive SMS and email notifications.  All PDFs have their own access level (hidden,
read-only, or full access) that applies to operators in operator groups that do not expressly
override it.

Importantly, PDFs are attached to access groups.  A cardholder can have a value for a PDF only if he
or she is a member of one of the PDF's access groups (Footnote:  direct or inherited.  Unless
otherwise noted, all Command Centre's access group membership tests treat inherited members just
like direct members).

The REST API allows you to manage a cardholder's group memberships (so that he or she has the PDF)
as well as see and set PDF values.  It does not let you see or change the configuration of the PDF
item.

## Divisions
Every item in the API is in a division (footnote:  except day categories.  They are divisionless).
Divisions are arranged in a tree:  each has exactly one parent, aside from the root division, which
has none.  An operator group specifies the roots of the division trees to which it grants
privileges.

Therefore an operator with privileges on the root division has those privileges on all that server's objects.

Complication:  multi-server clusters have one root node (and therefore one tree of divisions) per server.

If you find that an operator cannot see or modify an item, the questions you should ask are:

### Which division is the item in?
The Command Centre client shows a cardholder's division in the 'Cardholder Details' pane of the
cardholder viewer.  The Configuration Client shows the division of any item in the 'General' tab of
its property page.  The REST API shows it in the `division` field.

> **The operator's division and his or her operator groups' divisions in the 'General' tabs are
> irrelevant**. The operator group grants privileges on the divisions in the 'Divisions' tab.

## Roles
A role defines a relationship between two cardholders.  One cardholder can perform a role for many
others but can have it performed for them by only one other.  It makes more sense when you use the
example 'supervisor':  a person has a supervisor and is a supervisor for many others.  When you use
REST to look up or update a cardholder, you will work on the 'has a' relationships, not the 'is a'
relationships.  In other words you can change the cardholder's supervisor but not who the cardholder
supervises.

## Competencies
Basically, competencies are another condition that a cardholder must meet to pass an access check.

The REST API lets you manage the links between cardholders and competencies:  create them, delete
them, enable/disable them, and set their expiry dates.

A competency can be disabled, expired, both, or neither.  Actions at a door can depend on whether a
competency is disabled, expired, soon to expire, or all good.

Whether it is disabled is a flag, plain and simple.  Whether it is expired is derived from an expiry
date (actually a timestamp):  if it is in the past, Command Centre considers the competency expired.

A competency can also have an enable date.  If that date (timestamp) passes while the competency is
disabled, Command Centre will enable it.

If the competency is not disabled, the 'expires' time is important.  If it is in the past, the
cardholder's competency is expired.  If it is not set, or it is in the future, the cardholder
benefits from the competency.

| Enabled flag | Enablement date | Expiry date | Status
| ------------ | -------------- | --------| ----- |
| Set | - | Far future | Active |
| Set | - | Near future | Active (with a warning at the door) |
| Set | - | Past | Inactive (expired) |
| Unset | Future | - | Inactive (pending) |
| Unset | Past | - | Inactive (disabled) |
| Unset | null | - | Inactive (disabled) |

## Card types

A card type carries rules for the data that a card carries, PINs, how to treat cards around their
expiry time, and default values for new cards of that type.  We often use the word credential,
because not all card types involve a physical card:  there are also biometric and mobile card types.

The REST API provides read access to card types so that you can manage cardholders' credentials.

PIV cards have their own developer document, separate from the rest of the cardholder API.

## All the above are items

The API lets you search for items and examine them, but—other than cardholders and schedules—it does
not let create, alter, or delete them.  The purpose of the cardholder API is to let you associate
items with cardholders and manage those associations.

## Events and alarms
Events record occurrences in the system.  They are not items.  They have an ID, a source item, an
occurrence time, and links to other related items.  Events are immutable:  the events you read from
the REST API will not change.

Alarms are events with extra fields, and some of them are mutable:  there is a free-text notes field
that you can edit in the thick clients, a history, and Booleans recording whether the alarm is
acknowledged, processed, and active.

The alarms interface only shows unprocessed alarms in its search results.  Once an operator
processes an alarm, it disappears from alarm searches.  However, the alarm still exists in the
database and an alarm is also an event, so the events interface will return it whether somebody
processed it or not.

## Operator privileges
Or just 'privileges' since there is no other kind.

An operator has privileges over a division and all its subdivisions.  When we refer to an operator
having a privilege on a cardholder, for example, we mean that the operator has that privilege on the
cardholder's division, or one of its ancestor divisions.

In the interests of security, you should give your REST operators (footnote:  _all_ operators) the
minimum privileges they require to achieve their task.

An [appendix](#appendix--features-and-licences) gives some examples of privileges you will need for
various tasks.

## HTTP requests
An HTTP request has four parts:  a verb, an address, a handful of headers, and a body.

### Verbs
The verbs we will use are GET, POST, PATCH, and DELETE (in upper case by convention).  GET and
DELETE are self-explanatory but the other two are often confused.  In this API we use POST to create
something new such as a cardholder, and PATCH to modify something like the end-date on a group
membership.

### Addresses (URLs)
The address is the URL that everyone is accustomed to.  In a REST API the address identifies the
object you wish to GET, PATCH, or DELETE.  When POSTing, the address identifies the type of thing
you wish to create.

### Headers
Headers are a list of key/value pairs.  We use one called Authorization (spelled with a Z) to carry
client authentication, and one called Content-Type to be clear that we use JSON.

### Bodies
The body of a GET or DELETE request is empty.  A POST can also be empty, but they usually carry some
instructions for what you want created.  A PATCH always needs a body that contains instructions for
how to modify the item identified by the address.

If the body is not empty, it must contain JSON (below).

The sample application “CCFT REST Client” opens a console window that shows you the verb and address
of the HTTP queries it is making.  It can also show you the bodies of its queries and the server's
responses.

## HTTP responses:  codes, and more headers and bodies.
An HTTP response has three parts:  a numeric response code, more headers, and a body.

### Response codes
Any response in the 200-299 range means success.  GETs return a 200 along with their results.
DELETEs and MODIFYs return 204 (“no content”), which just means they succeeded and having nothing
more to say.  Creating a cardholder or event returns 201 (“created”).

A response in the 400-499 range generally means there was something wrong with the request.  One
exception is 409:  it could mean that your timing was bad and trying again later may succeed.  Along
with 404, 409 could also mean you have attempted to do something beyond your privilege.  The body of
the response that comes back from the server will tell you the problem.

500-level responses mean the server has met with trouble.  Waiting for updates on events or items is
an exception:  if you ask Command Centre for updates and none arrives before the timeout, it will
return 503.  That is actually a kind of success:  it means nothing changed while you were waiting,
so a future version of Command Centre may return a 200-level code in this case.

### Headers
The only time Command Centre returns a header of interest is after it processes a POST to create a
cardholder or event.  It sets a header called Location containing the URL of your new object.

### Bodies
The body of a GET response contains everything you asked for, in JSON.  The body that comes back
from other verbs is empty unless there was a problem.

Chrome will show you the body.  Press F12 and resend the request to make Chrome show you the
response code and the headers as well (along with lots of other useful information).  Postman (a web
client we will get to later) always shows you everything.

## JSON
...though familiarity with XML or any programming language should be enough.  With line breaks and
indentation and a bit of colour, JSON is quite readable.

JSON can contain flat fields, objects (structures), and arrays.

~~~javascript
{
    "a text field": "string",
    "a numeric field": 1234,
    "a Boolean field": false,
    "an object": {
        "sub-field1": "foo",
        "sub-field2": "bar"
    },
    "an array": [
        {
            "sub-field1": "jingle",
            "sub-field2": "bells"
        },
        {
            "sub-field1": "foo",
            "sub-field2": "bar"
        }
    ]
}
~~~

In that example, the array called an array shows an array containing two more objects, each of which
contains two fields of its own.

## Authentication and encryption certificates
Before an API call can succeed the client needs to decide to trust the server and then the server
needs to decide to trust the client.  They do that using _certificates_.

First a little background.  Very simply put, the current algorithms for secure communication require
a pair of _keys_.  Keys are nothing more than huge numbers.  The two in the pair are different, but
mathematically related so that when you encrypt some data using one key, nobody can decrypt it if
they do not have the other key.  The encryption key is public because there is no harm in encrypting
data.  People toss encryption keys around like business cards.  Its mate, the decryption key, is
very, very private.  They are not called the encryption and decryption keys because they do more
than just that, so the business card one is called the _public key_ and the other is the _private
key_.

A _certificate_ contains a public key plus metadata:  what the key is meant for, for how long, and
some proof that it is authentic, if there is any.  That proof of authenticity takes the form of a
signature from an authority that the internet has agreed to trust, such as Symantec or Verizon.
Client certificates, and some server certificates, do not have a signature.  Or they do, but it is
their own signature, which does not really count because nobody trusts it.  Such certificates are
called _self-signed_.  Web browsers cook up their own self-signed certificates all the time.  Web
server certificates, on the other hand, change infrequently (months or years).

If an HTTPS client and server connect and establish an encrypted channel of communication without
checking certificates nobody will be able to listen in, but they should not trust each other.  The
other end could be fibbing.  So they conduct a negotiation to establish each other's identity (i.e.,
they _authenticate_).

Usually a web client requires proof of authenticity from the server, since you want to be sure that
it really is your bank's web site you are looking at and not a fake.  If the server does not provide
that, the client shows a warning.  You will have to [work around it in
Chrome](#ignore-server-certificate-warnings) and [work around it in
Postman](#never-mind-that-your-server-certificate-is-self-signed).  If you want to install your own
server key, the topic 'Changing the Web Services' in the Configuration Client's online help shows
you how.

Sometimes the server also requires a proof of identity from the client.  This does not happen when
using most web sites because (continuing the bank example) your bank has not pinned your client
certificate:  it does not care where you are coming from.  But APIs should operate more securely
than web sites so our recommendation is to turn it on.  [A later section](#client-side-certificates)
talks about client certificates.

> &#9888; **It is important to know the difference between the two certificate checks, and to know
> that they are completely independent**.  If the client does not trust the server, Command Centre
> will not receive a connection and will not raise any alarms.  The problem is on the client and
> there is nothing you can do to Command Centre to help.  But if the server certificate is
> acceptable to the client, the server has a chance to check the client certificate.  If the server
> does not like the client certificate, Command Centre will raise an 'invalid client certificate'
> alarm.

## Items versus a cardholder's link to them
Talking about a PDF or a competency can be confusing, because there is a PDF item and a competency
item, and cardholders can have PDFs and competencies, but the item and the cardholder's link to the
item are different things.

The items (on the left in the table below) and the connection to a cardholder (on the right) both
appear in the REST API, but the API only lets you change the connections.  Until 8.50 added schedule
management, a cardholder was the only kind of item you could create or modify.  So let us make some
definitions:

| Item | A cardholder's possession of that item|
| --- | --- |
|Access group | Group membership|
|Competency | Cardholder competency |
|Role | Relationship (the role is the nature of the relationship between two cardholders) |
|Locker | Locker assignment |
|PDF | Cardholder PDF, or PDF value |

There is a question of scale.  You may have ten access groups, but thousands of group memberships.
You may have only one role in the system, but one relationship per cardholder.

For that reason, the API calls that list items do not list their connections to cardholders.  The
result sets would be too large.  Instead, you see those connections from the cardholder side:  when
you GET a cardholder's details, you will see all the connections that cardholder has to PDFs,
competencies, groups, cards, lockers, and roles.

Access groups and operator groups will show you their cardholder members, but only if you ask.

<!--
#####################################################################################
Setting up the SAD to receive REST calls.
#####################################################################################
-->

----------------------------------------------------------------------
# Set up Command Centre

## Turn on the web server

Configuration client -> File -> Server Properties -> Web Services (about 15 down).

Enable the REST API and--for the moment--tick the checkbox to the right of the port.  It has a
different label from this screenshot in 8.50.  Have a good look at the status because it is the
first indication of trouble binding a socket.

![Enabling the public API](assets/server_props_turnon.png "Enabling the web server")

The Configuration Client's online help covers this in the topic called 'Web Services'.

> &#9888; **Make sure 'Do not require pinned client certificates' is off in production**.  In 8.50
> it is called 'Enable REST Clients with no client certificate'.  It ships turned off:  make
> sure it stays off on production servers.

Requiring pre-shared certificates from clients is the best protection the server has against
attackers on its network.  If you tick the box to turn off that check when you first start your
development, come back once your application is connecting successfully and untick it again.  Read
the section on [client-side certificates](#client-side-certificates) to help get your application
connecting again.

### Installing a custom server certificate
You do not need to install a custom server certificate for experimental development.  If you
eventually choose to do it, it all happens under a button that arrived in Command Centre after I
took the screenshot above, labelled 'Manage Certificates'.  The Configuration Client's online help
covers it in detail in a section called 'Replacing the web service certificate' in the 'Changing the
Web Services' topic.  You can either import a public/private key pair into Command Centre (which is
simple) or use the Windows Certificate Store (which uses Microsoft's security instead of Command
Centre's).  The summary of the Certificate Store process is:  you need to name your certificate
'Gallagher Command Centre Server' (please take care with the spelling), place it in the 'Gallagher
Applications / Certificates' folder of the Local Computer Certificate Store, and give Command Centre
the rights to use it.  The online help lays that out step by step.

## Create a REST operator

We will get to the reasons why in [why we need an operator](#why-we-need-an-operator).

### Create an operator group and give it the necessary privileges

You can do this in either of the clients.

Give the group the lowest level privileges it needs.  For this exercise, you will need 'Create and
Edit Cardholders' and 'Edit Alarms'.  'Modify Access Control' and 'View Site' could be handy later.

![Adding privs to an operator group](assets/op_group_privs.png "Adding privs to an op group")

> &#9888; **Not 'Advanced User'.  Never 'Advanced User'**.

See [this appendix](#appendix--features-and-licences) for a table of privileges an operator needs
for common tasks.

One group is enough for experimenting but when it comes to production, create an operator group for
each class of client you have connecting and give each group different privileges.  An operator can
be in more than one operator group; use this flexibility as you need.

### Create a cardholder and add it to the operator group
You can do this in either of the clients.

![Adding cardholders to an op group](assets/op_group_members.png "Adding cardholders to an op group")

In production, your operator should have a bare minimum of capabilities, so do not give it a card,
logon, password, or user code.  Do give it plenty of description about what it does, where it
connects from, and who to contact about it, because the people running the security system will not
be the people who run your software integrations and they will need all the help you can give them
when problems arise.

During development it helps to log in to the Command Centre clients sometimes, so I give the REST
operator a logon, password, and the 'Launch Configuration Client' privilege.

Now that you have an operator, you need to let the REST API use it.

## Create a REST Client item

...(in the server) and assign an operator.

We call it a 'REST Client' but it is really a mapping from an API key to an operator.  More on this
later.

Using the Configuration client, Configure -> Services and Workstations (at the bottom).  Right-click
menu -> New -> REST Client.

Set a name, then go to the 'API Key' tab.

Drag your new operator (Manage -> Cardholders) into the 'REST Client Operator' box.  That box looks
like it can hold more than one:  it cannot.

Take a note of the API key.  You will need it for your clients (the sample app, Chrome, or Postman).

![A REST Client item's API key in the Configuration Client](assets/rest_client_api_key.png "A
REST Client item's API key in the Configuration Client")

IP filtering is a layer of security that makes it that much harder for an attacker to attack your
server.

![A REST Client's IP filters in the Configuration Client](assets/rest_client_ip_filtering.png
"A REST Client's IP filters in the Configuration Client")

(A space is as good as a comma.)

## What is an API key?

Your client sends this to Command Centre with every request.  It is the username and password
combined.  Take care of it.  If someone steals your API key and you have not taken other precautions
(client certificates and IP filtering) they could masquerade as you.

If something makes an API call without an API key, or with an API key that Command Centre cannot
find on one of the REST Client items, CC will raise an error 'A REST connection was attempted with
an invalid API key'.

When a client sends it to the server in an HTTP header it prepends 'GGL-API-KEY' and a space.  That
string is not part of the key and you should not use it in any of the places that expect an API key.
It is just there so the HTTP request conforms to an Internet standard.


----------------------------------------------------------------------

# Try the sample client application

This section needs fleshing out with proper prose, but until that happens the major points to cover
are:

The sample client is the quickest way to make sure CC is working properly.  For Windows users, it is
better than a web browser (which requires plugins and hides error messages) or Postman (which is
fiddly if the server is checking client certificates, and now requires online registration).

Find the sample client on the installation media under <tt>Utilities / REST API /
RESTClient_<i>version</i></tt>.  It has been there since 8.00.

It is not a Command Centre management application!  It is a library of sample code for developers,
which happens to compile and run.  You can check the status of many items, override most of them,
watch and create events, and create, look up, and move cardholders, but some features like lockers
and car parks are missing.

Watch the multi-coloured console to find out what URLs to use in your own requests.  Later versions
include options on the login screen to also show the JSON that the client is sending and receiving.

The source code for the demo app and a few others is on the installation media.


----------------------------------------------------------------------

# Set up Chrome
If the sample GUI app works and you want to see the data that comes from Command Centre, a web
browser is all you need.  If you also want to create and change items you should skip this section
and install Postman.

There are two extensions you need to install for Chrome to be really useful.  One sends the API key
to the server, and the other dresses up the JSON that it sends back.

## Install the ModHeader extension

You need to set a custom header, because that is how we send the API key and without that Command
Centre will give you nothing.

Start by clicking the 'Modify Headers' icon in Chrome.  (Footnote:  confusingly, there is also an
extension called 'Modify Headers', which is different from 'ModHeader'.  Use either.)

Set a header called Authorization with a value of GGL-API-KEY followed by a space and the API key
you took from the configuration client.  Note in the example below I have two headers ready to go,
only one of which is active.  They are too wide for the Modify Headers window (there are three more
characters).

In 7.90, both must be in upper case.

> &#9888; **Set a filter so that the header only goes to your Command Centre server.  Otherwise Facebook
> will have your API key**.

Use a URL pattern in the filter that all your queries will match but other web browsing will not.
ModHeader now uses regular expressions, so if you have dots in your hostname you must put
backslashes in front, `\.`.

![Install Mod Header Chrome extension](assets/chrome_mod_header_setup.png "Install Mod Header
Chrome extension")

## Install a JSON viewer
Raw JSON straight from the server contains no whitespace, so it is not that easy to read.  There are
a few Chrome extensions that pretty-print JSON for you.  I use 'Awesome JSON Viewer' because it is
recent (April 2020) and can collapse and count sub-items.  It is rebranding itself 'JSON Viewer
Pro', so you might try searching for that.  Despite having 'pro' in the name it remains free.

## Ignore server certificate warnings
Send Chrome to <tt>https://<i>your_host</i>:<i>your_port</i>/</tt> .  <tt><i>your_port</i></tt> is
probably 8904.  If your server does not have a certificate with a trust path to a trusted root
certificate, you need to click through the warning below.  It will reappear occasionally.  You can
turn it off in Chrome but it is not a good idea, since you want to know when other servers are using
self-signed certificates.

![Chrome fretting about a server cert](assets/chrome_bad_server_cert_1.png "Chrome fretting
about a server cert")
![Chrome fretting in more detail](assets/chrome_bad_server_cert_2.png
"Chrome fretting in more detail")

# Set up Postman

If you want to do more than look, you need Postman, because Chrome does not let you POST, PATCH, or
DELETE as easily as Postman does.

Postman used to be a Chrome extension but is now a standalone application.  Both work.  These
screenshots are from the application.

## Send the API header with every request
This is what the Modify Headers extension does in Chrome.  It makes Postman send an Authorization
header containing your API key with every request.

Your requests also need a Content Type header but you do not need to set it yourself.  Postman will
add that after the next step.

![Setting auth header in Postman](assets/postman_auth_header.png "Setting auth header in
Postman")

**There is a mistake in that screenshot**:  the value for the Authorization header should have
GGL-API-KEY and a space before the API key.


## Set the content type to JSON
Otherwise Command Centre will reject it as invalid.

![Content-type Postman header](assets/postman_content_type.png "Content-type Postman header")

You must use `application/json`, in lower case, nothing more.  People have tried adding a semicolon
and `charset=utf8`, but that just stops all queries from working.

## Never mind that your server certificate is self-signed
In the current version of Postman, the settings are behind the cog in the top tool bar, not the
sliders in the environment toolbar below it.

For older versions of Postman, the settings are behind the open-ended wrench in the top tool bar,
not the cog in the environment toolbar below it.

![Postman settings menu](assets/postman_server_cert_warning_off_1.png "Postman settings menu")

Pick 'Settings' and turn off SSL certificate verification.  Turn off the other options if you want
to keep it looking clean.  It makes no difference to Command Centre.

![Postman SSL cert verification off](assets/postman_server_cert_warning_off_2.png
"Postman SSL cert verification off")




# First GETs:  cardholders
## The most basic GET
Using Chrome, go to <tt>https://<i>your_server</i>:8904/api</tt> again.  This document and the
developer documentation use the following shorthand, which omits the protocol, host, and port:

    GET /api

Doing that will test everything you have set up so far.  If it did not work, look at the error
message in the response body (Chrome will show it) and the most recent events in Command Centre.

If it did accept your API key, the only thing that can stop you now is a licensing problem:

    {
        "message": "feature not licensed"
    }

With a RESTEvents licence you will get more:

    {
        "version": "7.90.0.0",
        "features": {
            "items": {2 items},
            "alarms": {3 items},
            "events": {4 items}
        }
    }

With a RESTCardholdersEvents licence:

    {
        "version": "7.90.0.0",
        "features": {
            "items": {2 items},
            "alarms": {1 item},
            "cardholders": {1 item},
            "events": {1 item},
            "accessGroups": {1 item},
            "roles": {1 item},
            "lockerBanks": {1 item},
            "competencies": {1 item},
            "cardTypes": {1 item}
        }
    }

That is not the exact JSON you will get---it's not even JSON---but hopefully you get the idea.

## Cardholder summary

    GET /api/cardholders

That translates to <tt>https://<i>your_host</i>:<i>your_port</i>i>/api/cardholders</tt> in Chrome or
Postman.

Your operator should be there.  Try following some of the links.  If you are using Chrome, just
click on them.

Next try:

    GET /api/cardholders?top=1

That limits the results to one cardholder.  If you don't have a `next` link in the result, it will be because
there is only one cardholder in your system or your operator only has access to one.

Now apply the advice from the efficiency section of the developer documentation for collecting a lot
of cardholders at once:

    GET /api/cardholders?sort=id&top=10000

v8.00 delivered the ability to add all the fields from the details page to the summary page, using
the `fields` parameter.  See the developer documentation for a proper description, but in short, try
adding <tt>fields=<i>fieldname</i></tt> to your request URL (after a `?` or `&` of course) where
<tt><i>fieldname</i></tt> is the name of a field you can see in a detail page, such as `cards` or
`accessGroups`.  For example:

    GET /api/cardholders?sort=id&top=10000&fields=firstName,lastName,cards

## Hrefs are URLs as well as identifiers

Notice the fields called href in the cardholder summary?  They are URLs, and hopefully you have
followed one already.  Some will return you a page of data, and some will 404.  We call them _hrefs_
rather than URLs because they are HTML references that, in our case, happen to be HTTPS URLs.

Hrefs are very important.  Each object in Command Centre -- events, alarms, items, connections
between them -- has one that identifies it.  You will be sending many of them in the bodies of your
requests.

## Cardholder detail

Follow one of the href links on the summary page:

    GET /api/cardholders/1234

1234 will be a different number on your system.  The API documentation uses the syntax
`/api/cardholders/{id}`.  Ignore the braces!  There are no braces in our URLs.

That GET shows you everything the REST API can tell you about the cardholder (footnote:  not quite
everything.  Mobile credentials and PIV and PIV-I cards have blobs of data that do not come out
unless you ask for them, because they are so large).  The developer documentation helps interpret
it.

> **This is the difference between a summary page and a detail page.**

The API documentation makes heavy use of the terms _summary_ and _detail_.  You see the summary of
an item at root URLs such as `/api/cardholders` and `/api/access_groups`, returned in an array of
many items of the same type as the results of a search.  You see the detail of a lone item by
following the item's href.

It worth becoming familiar with the structure of a cardholder in JSON because the REST API uses it
for summary and detail pages, and it expects very nearly the same structure when you create or
modify a cardholder.  They vary in the quantity of fields and their levels in the document.




# First GETs:  events

## List all events
This returns 1000, starting with the first recorded:

    GET /api/events

If it takes a while, it is because the JSON viewer extension in Chrome is pretty-printing it.

From there you can following the `next` link to get another thousand.  When you have extracted all
the events out of Command Centre, an `updates` link will replace `next`.  The `updates` URL is a
long poll link:  GETting it will block until more events arrive, or the call times out.

If you are writing a program that will extract all events out of Command Centre you should set `top`
(described in the API documentation) as high as you can.  Command Centre will cap it at 10,000.  You
do not gain much performance after a couple of thousand, but taking it higher reduces the number of
requests.

    GET /api/events?top=5000

## List all alarms

The alarms interface only returns alarms that have not been processed, i.e., those that are
'current'.  After an operator processes an alarm, it is merely an event with extra fields.

    GET /api/alarms

That will return at most 100 alarms.  You can follow the `next` link to get more, until you have got
them all and an `updates` link replaces it.  The `updates` URL is a long poll:  GETting it will
block until more alarms occur or the call times out.



# Back into the theory

## API controllers
_Controllers_ are different parts of the REST API.  Not to be confused with the controller hardware
Gallagher also produces, API controllers have the same name as the part of the request URL after the
leading `/api`.  The main ones are `alarms`, `events`, and `cardholders`.  `items` is there to
support searching for events.  `card_types`, `competencies`, `access_groups`, `roles`,
`operator_groups`, and `locker_banks` let you find items to attach to cardholders.

All controllers' names are plural, and pothole_cased.  You can find links to them all with

    GET /api

## Why we need an operator
Everything that happens to a cardholder happens because an operator did it.  The operator could be a
person working in one of the thick clients, or it could be one of the other APIs, but whenever a
cardholder changes, Command Centre must have an operator to pin it on.

Having an operator allows Command Centre to enforce privileges.  You limit what your REST operator
can do in case the client has bugs (and starts DELETEing URLs instead of GETting them) or the API
key becomes known to the other side.

It also helps auditing.  Each cardholder change causes an operator event, with the operator and
cardholders as related items.  Interactive changes use the workstation as the source, and REST
changes use the REST Client.  You can run reports that filter on the source and operator to monitor
your integration.

## The request process
All HTTPS requests start like this:

1. The client and server establish an encrypted channel.  Part of that is a certificate exchange.
   The channel makes the following conversation safe from eavesdroppers but does not confirm the
   identity of either side.
2. Unless you have configured your client not to, it verifies the identity of the server
   (authenticates it) by examining the contents of the certificate that came from the server during
   the previous step.  If the client does not like the certificate that came from the server, it
   drops the connection.  Command Centre will complain to its log file when this happens but because
   it did not receive a request, will not create an event.
3. If the client trusts the server it sends its request along with a secret that proves it is who it
   says it is.  In our case that is an HTTP header containing the API key.

So far that has been a normal HTTPS conversation, the same as what happens with every web site you
visit in a browser.  From here on is specific to Command Centre.

4. The server looks for the API key in the `Authorization` header and finds the matching REST Client
   (footnote:  capitalised to mean the configuration item in Command Centre, not the REST client
   software on the other end of the TCP connection) in the database.  If it cannot find one, it will
   raise an alarm 'A REST connection was attempted with an invalid API key'.

5. If you did not disable pinned client certificates in the server properties (Web Services tab), or
   if you are running 8.50 and the REST Client item has a thumbprint on it (in the API Key tab), it
   checks the thumbprint of the request's certificate against the one on the REST Client item.  If
   they do not match, it responds with a 401 and raises an alarm 'A REST connection was attempted
   with an invalid client certificate'.  The server does not check the client certificate's chain of
   trust.  [Another section](#client-side-certificates) has all the details of why you would want
   your server to check client certificates and how to create them.

6. It checks the source host's IP number against the REST Client item's IP filters.  If it does not
   match, it responds with a 401 and raises an alarm 'A REST connection was refused because of the
   connecting IP address does not match the IP filter on the REST Client '_name of your REST
   Client_''.

7. It checks that it has a license for the controller that will handle the request.  If it does not,
   it sends a 403 response containing the string 'Feature not licensed'.

8. It creates a new session for the operator, if there isn't one ready, then compares what the
   request is asking for against the REST Client's operator's privileges from the session.  If the
   privileges do not allow the operation that the client requested, the server will respond with a
   400-level error and a message in the body.

If all those steps succeed, the API controller processes the request, logs an operator event if
something changed, and returns a result.

The alarms above have a default priority of medium-high.  The server raises them for two reasons:
while developing, it is useful to have a little more diagnosis coming out of the server, and in
production, it is good to know when your API is being probed.

If too many bad requests arrive too quickly, the server will assume it is under attack and will log
an alarm at maximum priority, then will remain silent on the matter until the attack stops.

Errors also go to `%PROGRAMDATA%\Gallagher\Command Centre\Command_centre.log`.

----------------------------------------------------------------------

# First POST and search
## Create a cardholder
In Postman:

![POST to create a cardholder](assets/postman_create_cardholder_1.png "POST to create a
cardholder")

Notice that there are two headers set:  `authorization` contains the API key and `content type`
tells the server that the body is JSON.

This document uses this shorthand to represent that kind of HTTP query:

    POST /api/cardholders
    {
        "firstName": "New",
        "lastName": "Cardholder",
        "division": {
            "href":"https://localhost:8904/api/divisions/2"
        }
    }

The first line gives the verb and the file part of URL.  It needs the protocol, host, and port
prepended:  <tt>https://<i>your_server</i>:8904</tt>.  The rest is the body.

When you create a cardholder you must specify the division and either the first or last name, so
this example is about the shortest you can get away with.

Look at the response from the POST.  It contains a `Location` header giving the URL of our new cardholder.

![Create cardholder JSON results](assets/postman_create_cardholder_result.png "Create
cardholder JSON results")

You could GET that URL to see what you created, or...

## Search for a cardholder

    GET /api/cardholders?name=new

That will return all the cardholders with 'new' in their name.  It is case-insensitive.

To be more precise:

    GET /api/cardholders?name="cardholder, new"

Quotes make it a full string match, rather than a substring match.  It is still case-insensitive.

Note how Command Centre matches your search string against a concatenation of the cardholder's last
name, a comma, a space, and the first name.  It only does that if the cardholder has both names set.
Otherwise it just uses the one.

Also note that Chrome will turn the space into `%20`.

You should see your new cardholder in the results of both those queries.




----------------------------------------------------------------------

# Cardholder flat fields

“Flat fields” isn't a term the REST API uses but it means the simple data like names, description,
and PDF values that sit at the top level of a cardholder and do not have structures of their own.
Other data such as cards, access group memberships, and competency assignments are one level down,
in arrays, and contain other fields.

Before you can associate your cardholder with other items, you need to make them.

## Setup:  give a cardholder access groups and PDFs

For a cardholder to have a PDF, both need to be on the same access group.  You cannot create PDFs or
assign them to access groups via REST so you must do that in the Configuration Client.  Adding
cardholders to groups is possible via REST of course, but that is easier if you have an existing
group membership to compare your efforts against, so for now we will do that in the client as well.

### Create some PDFs
In the Configuration Client, Configure -> Personal Data Fields (second from the top).

Add -> New Personal Data Field.  Call it 'email' and set the type (on the Type tab) to Email.

You might as well make a few more with different data types.  Make at least one text, because they
have no constraints and are easiest to experiment with.

![Create a PDF in Configuration Client](assets/pdf_create_1.png "Create a PDF in Configuration
Client")

### Create at least two access groups, add the PDFs, and add your cardholder

In the configuration client, Manage -> Access Groups, right-click menu, New -> Access Group.

Open the cardholder and PDF lists out of the Manage menu so that you can drag items out.

Drag your new cardholder to the Cardholder Membership tab of the access group.

Drag your PDFs to the Personal Data tab of the access group.

Repeat!

![Add a PDF to a group in Config Client](assets/pdf_to_club.png "Add a PDF to a group in
Config Client")

Save everything and reload your cardholder's details to see what PDF values and group memberships
look like in JSON.  These sections in the cardholder API documentation cover it:

* 'Cardholder detail' gives the layout of a cardholder's detail page.
* 'Cardholder PDF' describes the items in the `personalDataDefinitions` array.
* 'Cardholder access group' describes the items in the `accessGroups` array.

Now you can change some of those values.

##  Change a name, authorise, change simple PDFs, set user code, etc.

This example changes a cardholder's first name and two PDFs, authorises it (de-authorised
cardholders always fail access checks), turns on a flag that allows extra unlock time on doors, and
sets the user code (which is a number you can use at keypads):

    PATCH /api/cardholders/{id}
    {
        "firstname": "Jeremiah",
        "@datePDF": "2099-03-31",
        "@email": "a@b.com",
        "authorised": true,
        "useExtendedAccessTime": true,
        "userCode": "1234"
    }

It looks like this in Postman:

![PATCH a cardholder in Postman](assets/postman_patch_cardholder_1.png "PATCH a cardholder in
Postman")

It looks a lot like that in the cardholder's details page too, so here is the rule:

> When PATCHing flat fields on a cardholder, send back the same kind of JSON you got from a GET.

## Image PDFs and Base64

Here is a cutting from the details page of a cardholder with an image PDF:

    "@datePDF": "2099-03-31T00:00:00Z",
    "@Email": "a@b.com",
    "@Mugshot": {
        "href": "https://localhost:8904/api/cardholders/325/personal_data/8449"
    } 

Notice that the image PDF does not show in a cardholder's details, because they can be massive.
Instead you get a URL.  If you follow that link you will see the image.

In order to send binary data in JSON (which cannot contain non-printable characters), you have to
encode it to Base64.  This turns raw bytes into a string of letters, numbers, plusses, and slashes
(64 possible characters), sometimes with equals signs on the end.  It also increases the size of the
data by about a third.  You can put the string between quotes and send it like any other PDF:

    PATCH /api/cardholders/{id}
    {
        "@photo": "Kilobytes+of+Base64+encoded+data==="
    } 

If you see a load of what looks like garbage ending with equals signs, it is probably Base64.


----------------------------------------------------------------------

# Cards

Meaning credentials.  In this section you will see how to give a cardholder a card and modify existing cards.

## Adding, updating, and deleting cards

Like all cardholder modifications, you do this with a PATCH to the cardholder href.  However a card
is not a flat field:  it is a member of an array in the cardholder object called cards.  To add an
item to the cards array, or change one, you pass in an object also called cards.  True to previous
advice, we do all operations in one PATCH.

Borrowing from the API documentation:

The cards object can contain three arrays, named add, update, and remove.  Every element you put in
those arrays should be in the card schema that you see in a cardholder detail.

Each element of the add array will need a type member, at the very least.  The only card field that
does not make sense here is href, because an href in a card block names an existing card and you are
creating one.  The example below adds two cards: one has nothing more than the type, so it will
receive a computed number and issue level, and blank from and until dates.  The other is a mobile
credential with a custom initial state 'Pending sign-off'.  You can tell it is a mobile credential
because only they have invitation blocks.

Each element of the update array should be a card to modify.  It will need the href of that card,
plus the fields you want to change.  Remember you cannot change a card's type.  The example changes
the issue level and resets the until date (making it valid forever).

The only field that makes sense in an element of the remove array is href.

Do not put the same href in both the update and remove arrays.

End quote.  Here is the example.  As well as adding two credentials, modifying a third, and removing
another, it authorises the cardholder and sets a PDF called `employeeID` just to remind you that you
can combine operations:

    PATCH /api/cardholders/{id}
    {
      "authorised": true,
      "@employeeID": "THX1139",
      "cards": {
        "add": [
          {
            "type": {
              "href": "https://localhost:8904/api/card_types/354"
            }
          },
          {
            "type": {
              "href": "https://localhost:8904/api/card_types/600"
            },
            "number": "Jock's iPhone 8",
            "status": {
              "value": "Pending sign-off"
            },
            "invitation": {
              "email": "jock@example.com"
            }
          }
        ],
        "update": [
          {
            "href": "https://localhost:8904/api/cardholders/325/cards/97b6a24ard6d4500a9d",
            "issueLevel": 2,
            "until": ""
          }
        ],
        "remove": [
          {
            "href": "https://localhost:8904/api/cardholders/325/cards/77e8affe7c7e4b56"
          }
        ]
      }
    }

Notice how the hrefs of a card include the cardholder's href and end with a long identifier.  That
is because a card is a property of a cardholder.  Do not read anything more into it:  treat it as
opaque.

## Don't delete cards:  disable them
Generally, when you have reason to stop a card from working you want a permanent reminder of why you
did it, you want to prevent another operator assigning the same card number to them later (so that
if someone finds a card on the ground and tries it, it won't open the building), and you want to
know who a lost card was assigned to in case it turns up again.  Command Centre achieves the first
two of these goals if you delete an old card but it is easier if you leave it card in the system,
non-functional.  You can set its end date into the past or set its state to one of the disabled
states.



----------------------------------------------------------------------

# Group memberships
In this section you will add your cardholder to an access group and modify the membership.

## Add an access group membership
You will need the href of your cardholder that you used in the [cardholder detail
GET](#cardholder-detail) or the [cardholder PATCH](#adding-updating-and-deleting-cards), or that
came back from your POST when you [created a cardholder](#create-a-cardholder).

You also need the href of your access group.  You can see all your access groups by querying the
access groups controller.  Hint:  `GET /api`.  Extra hint:  `GET /api/access_groups`.

When you have those two hrefs, substitute them into:

<pre>
PATCH /api/cardholders/325
{
  "accessGroups": {
    "add": [
      {
        "accessGroup": {"href": "https://localhost:8904/api/access_groups/<i>5388</i>"}
        , "from": "2017-01-31T02:11:00Z"
        , "until": "2037-01-31T02:11:00Z"
      }
    ]
  }
}
</pre>

(Remember that the first line does not go into the body of your HTTP query, and your actual URL will
start with `https://` with a host and port.  Also note the alternative comma style:  it makes
commenting lines out easier.)

If you use the wrong access group identifier, or your operator does not have 'Modify Access Control'
on the access group, you will be told:

    {
      "message": "Invalid access group href: https://localhost:8904/api/access_groups/53888"
    }

When you get it right, the server will return 204 and next time you GET your cardholder the result
will contain:

~~~
GET /api/cardholders/325
{
    // [...]
    "accessGroups": [
        {
            "href": "https://localhost:8904/api/cardholders/325/access_groups/1069",
            "accessGroup": {
                "name": "Boney M",
                "href": "https://localhost:8904/api/access_groups/5388"
            },
            "status": {
                "value": "Active",
                "type": "active"
            },
            "from": "2017-01-31T02:11:00Z",
            "until": "2037-01-31T02:11:00Z"
        }
    ]
}
~~~

The 'Cardholder access group' section of the cardholder API documentation helps with interpreting
that.

Take a copy of your version of the bold URL.  It is the href of the cardholder group membership,
which is a link between the cardholder (ID 325, in my case) and the access group (ID 5338).  It
starts with the href of the cardholder, because it is a property of that cardholder and serviced by
the cardholders controller, but do not try to interpret it more.  Certainly do not read anything
into the number on the end (1069), and do not be surprised if you have an item with the same ID.
Sections 16.3 and 16.4 go into what you should not do with hrefs.

## Edit an existing group membership

Change the URL of the cardholder and the access group membership in this PATCH:

    PATCH /api/cardholders/325
    {
        "accessGroups": {
            "update": [
                {
                    "href": "https://localhost:8904/api/cardholders/325/access_groups/1069",
                    "from": "2027-03-09"
                }
            ]
        }
    }

If it returns a 204, GET your cardholder again and look at its access group memberships.  The from
date should have changed from 2037 to 2027, and the membership href will be different.

The server changes the href after an update to prevent race conditions when there are two operators
active.  It means the two of you cannot change the group membership at the same time - the second one
in will fail.  The advice, therefore, is to update your cardholder as soon as possible after
retrieving its details (footnote:  probably good advice for a fetch and update on any API).

> **Do not cache the hrefs of links between items**.  They change with operator actions.



----------------------------------------------------------------------

# Create a cardholder, cont.

Now that you have access groups, cards, and PDFs, you can create a fully configured cardholder in
one request.  Here is an example that creates a cardholder, sets a PDF called 'email', puts it in an
access group (which is necessary for the PDF to work), and gives them a card.

<pre>
    POST /api/cardholders
    {
        "firstName": "New", "lastName": "Cardholder",
        "description": "Test cardholder",
        "division": {"href":"https://localhost:8904/api/divisions/2"}
        "useextendedaccesstime": true,
        "usercode": "1234",
        "@email": "a@b.com",
        "accessGroups": [
            {
                "accessGroup": {"href": "https://localhost:8904/api/access_groups/<i>334</i>"},
                "from": "2019-01-01"
            }
        ],
        "cards": [
            {
                "type": {"href": "https://localhost:8904/api/card_types/<i>342</i>"},
                "number":"3162"
            }
        ],
        "zzzcompetencies": [
            {
                "competency": {"href": "https://localhost:8904/api/competencies/<i>5394</i>"},
                "enabled": true,
            }
        ]
    }
</pre>

Never mind the competency yet.  The `zzz` makes the server ignore it.

First you will need to change the red numbers to the IDs of an access group and a card type on your
system.  You can get those with:

    GET /api/access_groups

and

    GET /api/card_types

In Chrome, those calls will look like <tt>https://<i>your_host</i>:8904/api/access_groups</tt> and
<tt>https://<i>your_host</i>:8904/api/card_types</tt>.

An actual application would also find the href of the correct division, but for today is it safe to
assume that the href of the root division is `.../divisions/2`.

After changing the first two italicised numbers, the `334` and the `342`, put the JSON into Postman
and POST it to /api/cardholders.  It should return you the href of a new cardholder, as it did in
11.1.

The `zzz` is in there to stop the REST API trying to add a competency to your new cardholder, which
would fail because you have not created a competency yet.  There is nothing special about three
'Z's—the server just ignores anything it does not recognise.

> **The server will ignore fields it does not recognise**.  Beware of this, as you may think your
> calls are succeeding when in fact they ard doing less than you want them to.

That is more of an advantage that a disadvantage.  It means we can write clients that degrade
gracefully on Command Centre servers that are not the most recent version or are missing licences.
Also, introducing typos to the names of your JSON objects is a convenient way of commenting them
out.  You can also prepend lines with `//`. It is not valid JSON but you can get away with it for
now.

Back to our example.  If you want to create a cardholder with a competency:
1. make a competency in the Configuration Client,
2. find its href from the competencies controller (`GET /api/competencies`),
3. change your JSON (remove the `zzz` and change the third italicised number), and
4. try the POST again.

It should fail, complaining that you cannot have two cards with the same card number.  Change the
`3162` and try again (or change number to znumber and let Command Centre pick a card number for
you - probably 3163).



----------------------------------------------------------------------

# Coding considerations

There are several things you should keep in mind when building an integration against this API.

## Recap

* `/api` returns links to summary pages.  Why that is important is in [the importance of
  `/api`](#the-importance-of-api)
* At time of writing, the URLs of most summary pages end with the name of the
  [controller](#api-controllers), such as `cardholders` or `access_groups`.  Others end with their
  specific purpose, such as `card_types/assign`, which returns the card types your operator can
  assign to people.
* Summary pages show you many items without much detail of each.  You can add sorting and pagination
  parameters.  [Cardholders](#cardholder-summary), [alarms and events](#first-gets--events), and
  [other items](#other-command-centre-items).  Always tell the API to sort its results by ID,
  because it is quicker and more reliable when operators are changing the database.  Unless you're
  writing a user app and really must have your results sorted by name.
* You can also add filters to summary pages, turning them into search pages.  See [searching for a
  cardholder](#search-for-a-cardholder) and [event filters](#event-filters).
* In v8.00+ you can add fields from the details page to the summary page of items, and in 8.40+,
  events.  Or you can specify the exact fields you need, if you want to save traffic.
* You walk the result set using links named `next` and `previous`.
* Detail pages give you more on an item, but only one item at a time.  Their URLs end with short
  alphanumeric identifiers.  [A cardholder](#cardholder-detail), for example.
* To create a cardholder, [POST the cardholders controller](#first-post-and-search).  The body of
  the POST is pretty much the same as you get from a GET of an existing cardholder, but with fewer
  fields.
* To update a cardholder, [PATCH its href](#cardholder-flat-fields).  That includes [adding
  cards](#cards).
* If you are changing PDFs or flat fields, the body of the PATCH looks a lot like what you got from
  a GET to the same URL.  Put `@`-symbols on the front of your PDF names.
* If you are updating cards, lockers, access groups, relationships, competencies, or operator
  groups, you will be sending arrays called `add`, `remove`, and `update` inside objects called
  `cards`, `lockers`, etc.

## Only one cardholder at a time
In all these flat field, card, and group membership examples you were working on one cardholder at a
time.  That is the only way you can operate, because the cardholder you are changing is named by the
URL.  If you want to change many cardholders, you must do it in a loop.

On the upside, you can change everything about the cardholder in one PATCH.  In fact, it is most
efficient to do so.  While you can use DELETE to remove one card or group membership or relationship
at a time, you will see much better throughput if you combine it with the other changes for that
cardholder and send them as one PATCH.  The same applies to creating a cardholder:  it is much
quicker to do it as one POST than as a POST followed by one or more PATCHes.  The other advantage is
that any one is atomic:  all the changes you put in the body happen, or none of them do.  So:

> When creating a new cardholder, do it all in one POST.  
> When modifying an existing cardholder, do it all in one PATCH.


## The importance of /api
Forgot all the URLs you have seen so far, except the first, and do not write them into your
applications.  The only address that your application should have coded into it is `/api`.  You can
learn every other address you need with a GET of that.  It will return a table of contents like
this:

    GET /api
    {
      "version": "7.90.0.0",
      "features": {
        "accessGroups": {
          "accessGroups": {
            "href": "https://localhost:8904/api/access_groups"
          }
        },
        "accessZones": {
          "accessZones": {
            "href": "https://localhost:8904/api/access_zones"
          }
        },
        "alarms": {
          "alarms": {
            "href": "https://localhost:8904/api/alarms"
          },
          "updates": {
            "href": "https://localhost:8904/api/alarms/updates"
          },
          "divisions": {
            "href": "https://localhost:8904/api/divisions/view_alarms"
          }
        },
        "alarmZones": {
          "alarmZones": {
            "href": "https://localhost:8904/api/alarm_zones"
          }
        },
        "cardholders": {
          "cardholders": {
            "href": "https://localhost:8904/api/cardholders"
          },
          "updateLocationAccessZones": {
            "href": "https://localhost:8904/api/access_zones/update_cardholder_location"
          },
          "changes": {
            "href": "https://localhost:8904/api/cardholders/changes"
          }
        },
        "cardTypes": {
          "cardTypes": {
            "href": "https://localhost:8904/api/card_types"
          },
          "assign": {
            "href": "https://localhost:8904/api/card_types/assign"
          }
        },
        "competencies": {
          "competencies": {
            "href": "https://localhost:8904/api/competencies"
          }
        },
        "doors": {
          "doors": {
            "href": "https://localhost:8904/api/doors"
          }
        },
        "events": {
          "events": {
            "href": "https://localhost:8904/api/events"
          },
          "updates": {
            "href": "https://localhost:8904/api/events/updates"
          },
          "eventGroups": {
            "href": "https://localhost:8904/api/events/groups"
          },
          "divisions": {
            "href": "https://localhost:8904/api/divisions/view_events"
          }
        },
        "fenceZones": {
          "fenceZones": {
            "href": "https://localhost:8904/api/fence_zones"
          }
        },
        "inputs": {
          "inputs": {
            "href": "https://localhost:8904/api/inputs"
          }
        },
        "items": {
          "items": {
            "href": "https://localhost:8904/api/items"
          },
          "itemTypes": {
            "href": "https://localhost:8904/api/items/types"
          },
          "updates": {
            "href": "https://localhost:8904/api/items/updates"
          }
        },
        "lockerBanks": {
          "lockerBanks": {
            "href": "https://localhost:8904/api/locker_banks"
          }
        },
        "macros": {
          "macros": {
            "href": "https://localhost:8904/api/macros"
          }
        },
        "outputs": {
          "outputs": {
            "href": "https://localhost:8904/api/outputs"
          }
        },
        "personalDataFields": {
          "personalDataFields": {
            "href": "https://localhost:8904/api/personal_data_fields"
          }
        },
        "roles": {
          "roles": {
            "href": "https://localhost:8904/api/roles"
          }
        }
      }
    }

You should parse the `features` block of that page for the URLs of the calls you need.  It contains
one block for each controller in the API:  cardholders, events, alarms, etc.  Some of those blocks
contain one more block, in turn containing an href for the base call for that controller.  Other
controllers (card_types) contain more than one, each containing an href for a different call.  For
example, the events and alarms controllers also provide a divisions call which lists the divisions
in which your operator has the privilege to see events and alarms, respectively.

### Do not code URLs into applications

Because Gallagher reserves the right to change them.  If you start at /api, your application will
stay compatible through Command Centre upgrades.

While it is tempting to hard-code a string "/api/cardholders" into your application, it is not that
much more development effort to get that URL from the contents page and make your code
forward-compatible.  Help yourself to the sample C#, starting with ClientManagerAsync.cs.

## Identifiers in your app

There are two API identifiers:  IDs and hrefs.
    
The REST API returns two kinds of identifier:

The short alphanumeric string that comes in a field called id is there purely for use in filters.
Because you add them to URLs they have to be short and free of punctuation, so we do not use the
longer identifier that comes next.  Section 17.1 shows how to use them to find events.

> &#9888; **Do not treat IDs as integers**.  They are alphanumeric.  A future version may add letters.

The URL that comes in a field called `href` is how you reference objects, both as addresses in your
own GETs, DELETEs, and PATCHes, but also in the bodies of those requests and POSTs when you need to
connect two objects.  When adding a card to a cardholder, for example, you need to send the href for
the new card's card type.  You would find that href using the card_types controller.  As another
example, when connecting two cardholders with a relationship, you need to PATCH the href of one of
the cardholders with the href of the role (from the roles controller) and of the other cardholder
(from a search of cardholders).

### Some hrefs are meant to 404
Many hrefs will respond to a GET, but some exist purely for identification:  cards, relationships,
and group memberships, for example.  Those hrefs are for use inside the body of a PATCH to modify a
cardholder.  You can DELETE some of them but GETting one of these will always return 404.

### Many hrefs are dynamic
Some hrefs change regularly:  access group membership IDs, for example, change every time you modify
the underlying membership, even if you only change its end-date.  For that reason you must start all
changes to a cardholder with a GET of that cardholder.  That will give you up-to-date hrefs for
linked group memberships, roles, cards, etc., which you can then use in the body of a PATCH.

### You can use them to cross-reference cardholders in an integration
External systems will have their own user identifiers:  staff or student ID numbers, usernames, or
national IDs.  You might like to store that ID in a PDF and use the PDF search
(<tt>/api/cardholders?pdf_<i>yyy</i>="<i>zzz</i>"</tt>, described in the developer documentation) to find
the href of your cardholder when it comes time to synchronise.  Then you do not have to store a copy
of the href.

That could be slow for large numbers of cardholders.  Instead, you could retain the href returned to
you when you created your cardholder and use that forever after.  There would be no need for a PDF
holding the external identifier inside Command Centre.

However that is no use for cardholders that your integration did not create.  Plus you risk losing
your cardholder if its href ever changes (which could occur if another operator or integration
deletes and recreates it, or Gallagher changes the layout of hrefs).

The recommended option is a blend of the two:  give every cardholder a PDF containing their external
ID and cache their href externally.  If your cache does not have it, or if using it returns a
400-level error, refresh your cache using a PDF search.

### Subtract the host and port then replace them with values from your integration's configuration
You will note that every cardholder href begins with the scheme, host, and port:
`https://localhost:8904` in these examples.  I am going to contradict earlier advice ever so
slightly and suggest that you drop the `https://host:port` from the front of an href before storing
it, then add the host and port from your integration's configuration before using it again.  By
doing that you give yourself the flexibility to change the hostname or port without invalidating
your cache of hrefs.

For example, for a cardholder with href `https://localhost:8904/api/cardholders/123`, store
`api/cardholders/123` in your database.  The application must have `locahost` and `8904` in its
configuration somewhere (how else could it make HTTP requests?), so when it comes to find that
cardholder again, prepend `https://localhost:8904/` to the stored value.  When your IT people change
the server's hostname or shift the service to another port, all you have to do is change your
configuration.  Which you had to anyway.

## Do not build your own hrefs from IDs
Buoyed with confidence gained following links around our API, you will be tempted to store just the
parts of hrefs that seem to matter and reconstruct them later.  In the interests of forward
compatibility:

> &#9888; **Do not interpret href paths, and do not build your own.**

As a reminder, the parts of a URL relevant to us are the protocol ('scheme'), host, port, path, and
query:

    scheme://host:port/path?query

The scheme will always be HTTPS—you can take that as read.  By all means, replace the hostname and
port number and add your own search parameters to the query on the end of URLs you take from GET
/api, but please do not tinker with the path.  Treat that as opaque.

For example, in version 8.10 the path to a locker was

    /api/locker_banks/locker_bank_id/lockers/locker_id 

In 8.20 it changed to

    /api/lockers/locker_id

Client code that inserts a locker bank ID and locker ID into the hard-coded string
`/api/locker_banks/{1}/lockers/{2}` will work against an 8.10 server but fail when the server
upgrades to 8.20.  Client code that takes the href from a locker bank page will work with both
versions.

## Sort by ID, and get all summary pages before any details

By default, item summaries arrive sorted by name.  That can cause a race condition:

1. You get the first 1000 cardholders, sorted by name.
2. Another operator (or your own update) changes the name of one of those cardholders to part of the
   alphabet you have not collected yet, or vice versa.
3. The next 1000 cardholders will either contain one you already received, or will skip one you did
   not.  There are three things you can do to reduce this risk:
   * Sort by ID.  Command Centre does not recycle them so no cardholder can slip into part of the
     database you have already extracted.
   * Collect hrefs from the summary pages, following the next link until it no longer arrives,
     before using any of them.  This means you collect everyone in the minimum possible time, and if
     you do update your cardholders you will not mess in your own yard.
   * Get thousands at a time so that you make fewer calls.
   
## Monitoring for cardholder changes is much better in 8.30
Version 7.90 supports change tracking through the events API.  If you filter for operator events you
will be informed of every change using long polls (below):  the href of the affected cardholder or
access group will be in the event.  In 8.00+ the href of the operator who made the change will also
be in the event.

Version 8.30 adds a call to the cardholders controller that makes synchronising them much simpler.
It can tell you which fields changed on a cardholder and what their values were before and after the
change, and what their current values are.  All the details are in a section called “Cardholder
changes” in the developer documentation but here is a quick run-down:

1. Send a GET to request a bookmark to the current head of the list of cardholder changes.
2. Synchronise your system with Command Centre using other cardholder methods.  It does not matter
   how long this takes.
3. GET the bookmark you received previously.  That will send you all the changes that happened since
   then, plus a new bookmark.
4. Process those changes, if there were any.  Sleep if there were not.
5. Go back to step 3.

To reduce the work you have to do and chatter on the wire using `filter` and `fields` query
parameters.  `filter` limits the changes you receive to those that you're particularly interested in
(you might not care about anything except changes to PDFs, for example), and `fields` lets you
request more or less data about each change and its cardholder.

## Long polls
A _long poll_ is a way for HTTP servers to send updates to interested clients.  The client registers
its interest by sending an HTTP GET, and the server pushes to the client by responding when
something of interest occurs.

Using telephone calls as an analogy, a traditional poll would have the client calling the server,
the server answering, then hanging up immediately if there was nothing to report.  The client would
then need to wait a time and try again.

If the telephone server supported long polls, however, it would leave the incoming call ringing
until it had something to say.  The client would carry on about its business until the server picked
up.  After hearing the server's response the client would call back when it wished.  Immediately if
it was in a particular hurry.

## Benchmarks
These are the results of informal performance tests of Command Centre 7.90 running on reasonably
capable hardware.

You will not achieve these numbers without following the advice in the 'efficiency tips' sections of
the developer documentation.

### Extracting events
Sustained an average of two to four thousand per second from a database of four million.

### Extracting 12,000 cardholders
Extracting their cards, access groups, and PDFs took three to four minutes on a v7.90 server.  The
process was to request a summary page of 10,000 cardholders, then the remaining 2,000, then iterate
through all their hrefs, getting their details pages.

Extracting the same fields for the same **12,000 cardholders took 12 seconds** on the same server
running v8.00.  This process used the fields parameter to add cards, access groups, and PDFs to the
summary page so that the test did not have to get any detail pages.

### Extracting 200,000 cardholders
Now on 8.30 and different hardware, extracting the names of 200,000 cardholders took one minute with
`top=1000&sort=id`, or 28 minutes without.  That is how important those query parameters are.  Use
them!

Part of the 3x speedup from the previous test will be due to the absence of PDFs:  they can be
expensive to extract.

### Creating cardholders
Ten thousand took an hour.  The test added a cardholder with a card and a handful of group
memberships and PDFs.

----------------------------------------------------------------------

# Advanced events

## Event filters

The developer documentation is authoritative on how to restrict your event results, but here is an
introduction.

You can filter by the occurrence date/time, the source item, the source's division, the event's
type, the type's group (all event types are grouped, and picking a group is synonymous with picking
a few types), or the event's cardholder.

| To filter by ... | Add a query parameter called... |
| --- | - |
|Event type |`type`|
|Event type group| `group`|
|Cardholder| `cardholder`|
|Source |`source`|
|Division| `division`|
|Date| `after` and / or `before`|

For example, to find all card events ('access granted', 'access denied', etc.):

    GET https://localhost:8904/api/events?group=23

The API documentation shows you where the 23 comes from.

To watch two cardholders:

    GET https://localhost:8904/api/events?id=325,8445

## IDs to use in filters
To keep the query strings manageable, these filters take short, alphanumeric strings as IDs rather
than the URLs that the API generally uses for identifying items.  In 7.90 and 8.00 these IDs are low
numbers, but we reserve the right to introduce letters in the future, so do not interpret them as
integers.

These are your options for finding the IDs you need to build a filter string:
* look at one of the events you want.  Everything you can filter by is there;
* look at `/api/events/groups` for event types and their groups;
* look at `/api/cardholders` for cardholders;
* look at `/api/items` for all other items, using a type filter of its own from looking at
  `/api/items/types`;
* if running v8.00 or later, look at the controllers for doors, outputs, alarm zones, access zones,
  and fence zones, linked from `/api`;
* If running v8.10 or later, look at the inputs controller.

For example, to find all your doors in 7.90, you would

    GET https://localhost:8904/api/items?type=11

That 11 came from

    GET https://localhost:8904/api/items/types

If you have 8.00 or later, just

    GET https://localhost:8904/api/doors

(after getting that URL from `GET /api`, of course)

## Filtering by date
Even though the before and after fields are only accurate to a second, filtering by date is 'smart'
for reports:  the result set will not include events that occurred during the before second.  For
example, `before=2019-01-01T00:00:00Z` will not return you any events from 2019.  Pass the `before`
parameter for one report as the `after` parameter of the next.  You never need to use `23:59:59`,
and there is no risk of missing an event that happens in the last second, or in a leap second.

All date-times should be in ISO-8601.  If you omit fields (such as minutes or seconds) Command
Centre will assume sensible defaults, but the best advice is to be explicit (especially about the
time zone).

> &#9888; **Put a timezone specifier in all date-times!**

## Adding PDF values to the cardholders in events
Card events such as 'access granted' use the door as the source but also have a related cardholder.
The event JSON includes the cardholder's name and href, but if you want to use your own identifiers
for cardholders you can also ask for a PDF to come out with the event.  Do that by adding
<tt>fields=defaults,cardholder.pdf_<i>XXXX</i></tt> where <tt><i>XXXX</i></tt> is the ID of the PDF.
Find that ID with a query to `/api/personal_data_fields`, adding `?name="your_pdf_name"` if you want
Command Centre to do the searching for you.

In order to see that PDF, your REST operator will need the appropriate privileges.  Otherwise the
event will come out without the PDF.  'View Cardholder' on the cardholder might not be enough:
while PDFs are visible by default, an operator can hide them, in which case your REST client's
operator group will need to override that to readable or read/write.

## Writing an interactive event viewer
If I was writing an interactive application to monitor events as they occurred, while also allowing
browsing the event history, I would get the most recent—enough to fill a screen—with:

    GET /api/events?previous=true&top=20

Then I would set an asynchronous task waiting on the `updates` link, which would return with new
events as they happened.

At the same time I would follow the `next` and `previous` links to collect more events as my user
scrolled back and forth.

## Worked example:  reading alarms
What follows is a series of calls that collect alarms from the 7.80 version of the alarms API.
There may be extra fields in later versions of Command Centre.

### Collecting all unprocessed alarms with one active forced door
The initial HTTP GET of `http://localhost/api/alarms` returns all unprocessed alarms: a bad login, a
network problem, and two forced doors, in this example.  The second forced door is still open, so
the alarm is active and instead of links for processing it we have links for force processing it,
because you are not really meant to process active alarms.

Note they are in the order that they arrived at the server, not the order they happened.
Interesting pieces are bold.

<pre>
{
  "alarms": [
    {
      "href": "http://localhost:8904/api/alarms/289",
      "id": "289",
      "time": "2016-11-10T14:17:00",
      "message": "<b>Operator logon failed</b> for FT Workstation on GNZ-PC1302",
      "source": { "name": "FT Workstation on GNZ-PC1302" },
      "type": "Operator Logon Failed",
      "priority": 3,
      "state": "unacknowledged",
      "active": false,
      "division": { "href": "http://localhost:8904/api/divisions/2" },
      "view": { "href": "http://localhost:8904/api/alarms/289/view" },
      "comment": { "href": "http://localhost:8904/api/alarms/289/comment" },
      "acknowledgeWithComment": { "href": "http://localhost:8904/api/alarms/289/acknowledge" },
      "acknowledge": { "href": "http://localhost:8904/api/alarms/289/acknowledge" },
      "processWithComment": { "href": "http://localhost:8904/api/alarms/289/process" },
      "process": { "href": "http://localhost:8904/api/alarms/289/process" }
    },
    {
      "href": "http://localhost:8904/api/alarms/296",
      "id": "296",
      "time": "2016-11-10T13:58:16",
      "message": "<b>Fat controller - Command Centre comms interrupted</b>",
      "source": { "name": "Fat controller" },
      "type": "Comms failed to Command Centre",
      "priority": 6,
      "state": "unacknowledged",
      "active": false,
      "division": { "href": "http://localhost:8904/api/divisions/2" },
      "view": { "href": "http://localhost:8904/api/alarms/296/view" },
      "comment": { "href": "http://localhost:8904/api/alarms/296/comment" },
      "acknowledgeWithComment": { "href": "http://localhost:8904/api/alarms/296/acknowledge" },
      "acknowledge": { "href": "http://localhost:8904/api/alarms/296/acknowledge" },
      "processWithComment": { "href": "http://localhost:8904/api/alarms/296/process" },
      "process": { "href": "http://localhost:8904/api/alarms/296/process" }
    },
    {
      "href": "http://localhost:8904/api/alarms/301",
      "id": "301",
      "time": "2016-11-10T14:18:27",
      "message": "<b>Warehouse door has been forced.</b>",
      "source": { "name": "Warehouse door" },
      "type": "Forced Door",
      "priority": 8,
      "state": "unacknowledged",
      "active": false,
      "division": { "href": "http://localhost:8904/api/divisions/2" },
      "view": { "href": "http://localhost:8904/api/alarms/301/view" },
      "comment": { "href": "http://localhost:8904/api/alarms/301/comment" },
      "acknowledgeWithComment": { "href": "http://localhost:8904/api/alarms/301/acknowledge" },
      "acknowledge": { "href": "http://localhost:8904/api/alarms/301/acknowledge" },
      "processWithComment": { "href": "http://localhost:8904/api/alarms/301/process" },
      "process": { "href": "http://localhost:8904/api/alarms/301/process" }
    },
    {
      "href": "http://localhost:8904/api/alarms/306",
      <b>"id": "306"</b>,
      "time": "2016-11-10T14:21:41",
      <b>"message": "Front door has been forced."</b>,
      "source": { "name": "Front door" },
      "type": "Forced Door",
      "priority": 8,
      "state": "unacknowledged",
      <b>"active": true</b>,
      "division": { "href": "http://localhost:8904/api/divisions/2" },
      "view": { "href": "http://localhost:8904/api/alarms/306/view" },
      "comment": { "href": "http://localhost:8904/api/alarms/306/comment" },
      "acknowledgeWithComment": { "href": "http://localhost:8904/api/alarms/306/acknowledge" },
      "acknowledge": { "href": "http://localhost:8904/api/alarms/306/acknowledge" },
      <b>"forceProcess": { "href": "http://localhost:8904/api/alarms/306/process"</b> }
    }
  ],
  "updates": { "href": "http://localhost:8904/api/alarms/updates?id=306" }
}
</pre>

### Collecting updated alarms after closing the door
Next we close the front door, the kicking in of which caused alarm 306, and GET the updates URL at
the end of the previous result, `http://localhost/api/alarms/updates?id=306`.  Because the alarm is
no longer active we do not have a link for force-processing it; instead we have links for processing
it normally with or without comments.

<pre>
"updates": [
  {
    "href": "http://localhost:8904/api/alarms/306",
    <b>"id": "306"</b>,
    "time": "2016-11-10T14:21:41",
    "message": "Front door has been forced.",
    "source": { "name": "Front door" },
    "type": "Forced Door",
    "priority": 8,
    "state": "unacknowledged",
    <b>"active": false</b>,
    "division": { "href": "http://localhost:8904/api/divisions/2" },
    "view": { "href": "http://localhost:8904/api/alarms/306/view" },
    "comment": { "href": "http://localhost:8904/api/alarms/306/comment" },
    "acknowledgeWithComment": { "href": "http://localhost:8904/api/alarms/306/acknowledge" },
    "acknowledge": { "href": "http://localhost:8904/api/alarms/306/acknowledge" },
    "processWithComment": { "href": "http://localhost:8904/api/alarms/306/process" },
    <b>"process": { "href": "http://localhost:8904/api/alarms/306/process" </b>}
  }
],
"next": { "href": "http://localhost:8904/api/alarms/updates?id=306.1" }
</pre>

### Updating after cutting power

This is the result of `http://localhost/api/alarms/updates?id=306.1` (the` next` link from the
previous results) after cutting power to the controller and waiting a minute for Command Centre to
raise an alarm about it.

<pre>
"updates": [
  {
    "href": "http://localhost:8904/api/alarms/308",
    "id": "308",
    "time": "2016-11-10T14:35:21",
    "message": "Controller \"Fat controller\" Offline.",
    "source": { "name": "Fat controller" },
    <b>"type": "Controller Offline"</b>,
    "priority": 6,
    "state": "unacknowledged",
    <b>"active": true</b>,
    "division": { "href": "http://localhost:8904/api/divisions/2" },
    "view": { "href": "http://localhost:8904/api/alarms/308/view" },
    "comment": { "href": "http://localhost:8904/api/alarms/308/comment" },
    "acknowledgeWithComment": { "href": "http://localhost:8904/api/alarms/308/acknowledge" },
    "acknowledge": { "href": "http://localhost:8904/api/alarms/308/acknowledge" },
    "forceProcess": { "href": "http://localhost:8904/api/alarms/308/process" }
  }
],
"next": { "href": "http://localhost:8904/api/alarms/updates?id=308" }
</pre>

### Updating after restoring power
Next we GET `http://localhost/api/alarms/updates?id=308` (the `next` link from the previous results,
again) after restoring power to the controller and waiting for it to come online.

The 'controller offline' alarm (ID 308) has changed to inactive since the controller has reappeared
on the network.

The 'low power' alarm has arrived from the controller stamped when it lost power, while it was
running on internal reserve power, one minute earlier than the 'controller offline' alarm.

Bringing up the rear is another alarm that the controller generated when it restarted.

<pre>
{
  "updates": [
    {
      "href": "http://localhost:8904/api/alarms/308",
      "id": "308",
      <b>"time": "2016-11-10T14:35:21"</b>,
      "message": "Controller \"Fat controller\" Offline.",
      "source": { "name": "Fat controller" },
      "type": "Controller Offline",
      "priority": 6,
      "state": "unacknowledged",
      <b>"active": false</b>,
      "division": { "href": "http://localhost:8904/api/divisions/2" },
      "view": { "href": "http://localhost:8904/api/alarms/308/view" },
      "comment": { "href": "http://localhost:8904/api/alarms/308/comment" },
      "acknowledgeWithComment": { "href": "http://localhost:8904/api/alarms/308/acknowledge" },
      "acknowledge": { "href": "http://localhost:8904/api/alarms/308/acknowledge" },
      "processWithComment": { "href": "http://localhost:8904/api/alarms/308/process" },
      "process": { "href": "http://localhost:8904/api/alarms/308/process" }
    },
    {
      "href": "http://localhost:8904/api/alarms/310",
      "id": "310",
      <b>"time": "2016-11-10T14:34:01"</b>,
      "message": "Fat controller - power low.",
      "source": { "name": "Fat controller" },
      "type": "Controller power low",
      "priority": 6,
      "state": "unacknowledged",
      "active": false,
      "division": { "href": "http://localhost:8904/api/divisions/2" },
      "view": { "href": "http://localhost:8904/api/alarms/310/view" },
      "comment": { "href": "http://localhost:8904/api/alarms/310/comment" },
      "acknowledgeWithComment": { "href": "http://localhost:8904/api/alarms/310/acknowledge" },
      "acknowledge": { "href": "http://localhost:8904/api/alarms/310/acknowledge" },
      "processWithComment": { "href": "http://localhost:8904/api/alarms/310/process" },
      "process": { "href": "http://localhost:8904/api/alarms/310/process" }
    },
    {
      "href": "http://localhost:8904/api/alarms/313",
      "id": "313",
      "time": "2016-11-10T14:35:49",
      "message": "Controller \"Fat controller\" restarted after power failed.",
      "source": { "name": "Fat controller" },
      "type": "Power failed",
      "priority": 6,
      "state": "unacknowledged",
      "active": false,
      "division": { "href": "http://localhost:8904/api/divisions/2" },
      "view": { "href": "http://localhost:8904/api/alarms/313/view" },
      "comment": { "href": "http://localhost:8904/api/alarms/313/comment" },
      "acknowledgeWithComment": { "href": "http://localhost:8904/api/alarms/313/acknowledge" },
      "acknowledge": { "href": "http://localhost:8904/api/alarms/313/acknowledge" },
      "processWithComment": { "href": "http://localhost:8904/api/alarms/313/process" },
      "process": { "href": "http://localhost:8904/api/alarms/313/process" }
    }
  ],
  "next": { "href": "http://localhost:8904/api/alarms/updates?id=313" }
}
</pre>

----------------------------------------------------------------------

<!-- s18 -->
# Client-side certificates

First see [auth certificates](#authentication-and-encryption-certificates) for what certificates are
and what the difference is between server certificates and client certificates.

This section deals with the client certificate check that happens if you left 'Do not require pinned
client certificates' off in the 'Web Services' property tab of an 8.40 server, or if you entered a
thumbprint into a REST Client item in 8.50 or later.

The process in [the request process](#the-request-process) shows that if you have not disabled
client certificate checking, the server does it after extracting the API key.  If the server does
not have the client's certificate pinned to the REST Client item with that API key, it will reject
the request and raise an alarm:

    A REST connection was attempted with an invalid client certificate

That alarm will be at the same priority as a controller disappearing off the network, which should
cause a stir, so try not to do it in production.

The next two sections should help you decide whether to use the feature.  The sections following
those contain sample command lines that you can paste into a shell on your clients to create client
certificates on disk or in the Windows certificate store.  If you receive syntax errors, you may
have an old version of the software (I have had problems with `New SelfSignedCertificate` on Windows)
or the hyphens may not be hyphens:  they may come through as dashes, which look very similar to us
but not to shells.  You may have to re-type them.

The bold in the sample command lines reduce the protection around your private key.  That may be
acceptable in a development environment but for proper security in a production environment you
should omit the bold parts.

## What the feature does
When not disabled by [the checkbox](#the-mysterious-client-certificate-checkbox) in the server
properties, Command Centre requests proof from the client that it has the private key that matches a
public key that the server has configured into it (pinned).  A public key is hundreds of bytes so
you don't want to paste the whole thing into Command Centre's configuration, and we do not want to
compare all those bytes for each request, so you enter a signature instead.  It is known as the
certificate's thumbprint or fingerprint, and is a cryptographic hash of the whole certificate.  It
is impossible for a client to send a fake certificate with a thumbprint that looks real.

Certificates can also contain a chain of trust linking the certificate back to a trusted authority.
A client uses a server certificate's chain of trust to check the identity of the server that
responded to its request.  It does not work in reverse:  servers do not check that part of a
client's certificate.  You would not have pasted the certificate's thumbprint into Command Centre if
you did not trust it.

When you enter a thumbprint into a CC REST Client's property page in the Configuration Client or
leave the checkbox we are covering next unchecked in the server properties, you are saying that only
the caller who has the matching private key is allowed to use that REST Client.  In other words, the
client software must possess two secrets that the server can verify:  the API key and the private
key.

Before getting into why you want all this checking happening, we should cover how to turn it on.
Or, since the product ships with it turned on, why you should not turn it off.

### The mysterious client certificate checkbox

In 'Server Properties', which you get to in the Configuration Client starting with the 'File' menu
or the top item in your hardware tree, there is a tab called 'Web Services'.  In there, in the box
headed by 'Enable REST API', is a checkbox.  In 8.40 it was called 'Require pinned client
certificates'.  In 8.50 it is called 'Enable REST Clients with no client certificate'.

It behaves like this:

| 8.40 | 'Do not require pinned client certificates' *off* | 'Do not require pinned client certificates' *on* |
| --- | - | - |
| Connection attempt to a REST Client item *with* a certificate thumbprint configured | Client certificate checked | Client certificate ignored, connection accepted |
| Connection attempt to a REST Client item *without* a certificate thumbprint configured | Connection rejected | Connection accepted |

In 8.50, the top-right quadrant changed.

| 8.50 | 'Enable REST Clients with no client certificate' *off* | 'Enable REST Clients with no client certificate' *on* |
| --- | - | - |
| Connection attempt to a REST Client item *with* a certificate thumbprint configured | Client certificate checked | **New in 8.50:  client certificate checked** |
| Connection attempt to a REST Client item *without* a certificate thumbprint configured | Connection rejected | Connection accepted |

That change will have negatively affected sites that had 'Do not require...' turned on, but also had
thumbprints (uselessly) configured into their client items.  However there is a huge upside to the
change:  in 8.50 or later a site can have some clients using client certificates and some not.


## Why use client certificates?
To make it harder for an attacker to masquerade as a legitimate REST client.

To do that, they must obtain your API key at the very least.  There are more barriers that you can
put up:

| If you: | ...the black-hat will then have to: |
| --- | - |
|use a firewall (Windows or hardware)| be on the server network.|
|use an IP filter| spoof the source IP.|
|pin your client's certificate| have a copy of the client's private key.|
|limit your application privileges| settle for less access.|

Pinning a client certificate is one more hoop an attacker has to jump through.

You should make viewing your private key very difficult for anything that does not need it.  Do not
leave it in the filesystem for anyone to read!  If you are running on Windows, you should use the
certificate store.  If you are on another O/S, protect the key while it is on disk with filesystem
permissions and by encrypting it with a password hidden in your application.

## Create a certificate and record the thumbprint in CC

These commands create a client certificate, so you need to run them on the system that will be
running your REST client.  That is probably not your Command Centre server.

### Using OpenSSL tools
This works equally well on any system with OpenSSL installed, including Windows, but the later
sections might serve Windows people better because they show how to put the certificate directly
into the certificate store.  These OpenSSL commands put the private key on disk, which should make
you a bit nervous if you are doing it in production.  On a Unix-like system you could do it in a
mode-0700 folder on a filesystem that is not backed up and is cleared during a reboot, such as `/tmp`.

<pre>
openssl req -x509    \
-newkey rsa:4096     \
-sha256              \
<b>-nodes</b>               \
-keyout rest.pem     \
-out rest.pem        \
-subj "/CN=RESTtest" \
-days 3650
</pre>

Notice the `rsa:4096`:  a four-kilobit key might be overkill for development, but the option is
there.

Again, the bold means that option reduces your security.  In this case, the `-nodes` option
(footnote:  it means 'no DES'.  It is not the plural of 'node') means there is no password on the
private key.  Anyone could read it from `rest.pem`, so in a production environment you should omit
that option and type in a password (a really good one) when `openssl req` prompts you.

To get the thumbprint for Command Centre:

    openssl x509 -fingerprint -in rest.pem -noout

If you protected the PEM with a password, `openssl x509` will ask you for it.

> Those are the 20 bytes that you paste into the REST Client item in Command Centre.

Now you need to add it to the clients that need it.  If you use Postman, see [this
section](#use-the-certificate-in-your-client).  If you use Chrome on Windows, you
need to add it to the certificate store with these two commands:

<pre>
openssl pkcs12 -export -in rest.pem -out rest.pfx <b>-passout pass:</b>
explorer rest.pfx
</pre>

The first command converts the PEM file into a file format that Windows prefers.  The `-passout
pass:` option means it will not put a password on it, so it is just as dangerous as the PEM file.

The second line will open `rest.pfx` in Explorer (like double-clicking it) to import it into the
certificate store.  The default options are good:  current user, determine the certificate store
automatically, and mark the private key as not exportable.

Finally, for goodness' sake, protect the `rest.pem` and `rest.pfx` files.  Preferably delete them,
using an eraser utility.

### Using Windows tools
If your client is on a Windows host there are two more ways to create a certificate and place it
into Windows's certificate store.  Obtaining the private key from there is easy for your client
program but difficult for anyone else, Microsoft assures us.

#### Powershell

The topic 'Creating the Client Certificate' in the Configuration Client's online help contains
instructions for doing it in a PowerShell with `New-SelfSignedCertificate`.  Handily, it prints the
thumbprint to the console so you can copy it into Command Centre.  You should try that first, since
it is simplest.  But `New-SelfSignedCertificate` is not present on all versions of Windows, so here
is an alternative using...

#### makecert

...which has been around for longer.

1. Run a developer command prompt as administrator.  If you do not have a developer command prompt,
   try a regular command prompt (as administrator).
2. In it:

    <pre>
    makecert c:\ignoreme.der
             -a sha1
             -ss My
             -sky signature
             <b>-pe</b>
             -len 2048
             -n "CN=RESTClientCert"
             -sr CurrentUser
    </pre>

That will create a certificate and place it in your certificate store with a copy on disk.

The `-pe` marked the key as exportable—more on that later.

You do not need to keep the file `ignoreme.der`, but the easiest way to get the thumbprint of your
new certificate is to open `ignoreme.der` by double-clicking on it in Explorer, go to the Details
tab, scroll to the bottom, and click the thumbprint.  You could then skip the next three steps, but
when starting out it is a good idea to carry on and verify that `makecert` put your new certificate
where it should have.


3. Run `mmc`, add the Certificates snap-in to manage “My user account,” open it and then your
   “Personal” certificates.
4. Ensure you can see a certificate called 'RESTClientCert' in there.  This is the cert you will
   pick for your browser later.
5. Double-click it, go to the Details tab, scroll to the bottom, and click the thumbprint.

> Those are the 20 bytes that you paste into the REST Client item in Command Centre.

#### Aside: other ways of calculating the thumbprint
For your information, here are three more command-line options for extracting the thumbprint from
the DER file if you didn't get it above.  They all do the same thing.  Use whichever works for you:

    openssl x509 -in c:\ignoreme.der -inform der -noout -fingerprint
    openssl sha1 c:\ignoreme.der
    sha1sum c:\ignoreme.der

As you can see from the last two, a certificate thumbprint is really just the SHA1 hash of the
certificate when it is stored in a DER file.

#### Marking keys as exportable

The `-pe` option to your `makecert` command above marked your private key as exportable.

You can mark it as not exportable, so that the standard utilities will not be able to get it out of
the certificate store.  While there are programs out there that can export non-exportable
certificates, anything you can do to make the black-hat's job harder is a win.

The trouble is that in order to use your client certificate in Postman, you have to export the key.

If you used the command `New-SelfSignedCertificate` in Windows Powershell (using the instructions in
the Configuration Client's user guide), you can mark the certificate not exportable by adding
`-KeyExportPolicy NonExportable` to the command line.

If you used `makecert`, remove the `-pe` and your new key will not be exportable.

### Extract the certificate and private key from the Windows store to disk

If you are going to use Postman you need to give it files containing your private key and
certificate, but if you used one of the Windows utilities to create a certificate and put it in the
certificate store, you will not have the private key on disk.  You will need to extract it.

1. Run mmc.  Certificates -> Current User -> Personal -> Certificates
2. Right-click your certificate -> All tasks -> Export...  
   Select the option to export the private key.  Give it a password, otherwise openssl cannot decrypt it.  
   It does not matter what you do with the other certificates, so leave the defaults set.  
   Export it to a `.pfx` file on disk.  

   That PFX is partly secure because you put a password on it, but I expect that password was very short so, again, be careful what you do with that file.
   
3. For old versions of Postman, you may have to convert that PFX into a file it understands.  The
   current version of Postman does not need this

   <pre>openssl pkcs12 -in restexported.pfx –out rest.pem <b>–nodes</b></pre>

It will ask you for the password you picked for the export.  It will put the certificate and the
private key in the PEM file, unencrypted (because of `-nodes`).  It is plain text:  you can look at
it in Notepad.

### An easy (but not so secure) way to discover your client certificate's thumbprint

Create a client certificate using one of the methods above and use it in an API call.  The server
should raise an alarm, complaining that 'a REST connection was attempted with an invalid client
certificate'.  The rest of that message will tell you which REST Client Item you need to put the
thumbprint on, and the details string will contain the thumbprint itself.

If the thumbprint is '(null)', your client is not sending a certificate at all.

Otherwise, copy the thumbprint straight out of there and paste it into the item.  The next time you
try your call the server should not complain about the certificate.

The reason this method is not so secure is that you cannot be sure that alarm was yours.  Someone
else may have hit the API before you did.

## Use the certificate in your client
### Postman
The standalone version of Postman cannot read certificates out of the certificate store (footnote:
the Chrome extension can, but it is no longer under development).

Go to the cog -> Settings -> Certificates.  Add a certificate that Postman will use when talking to
your server and port, using the
file containing the certificate where Postman asks for the CRT file and the file containing the
private key where Postman asks for the key file.  They will both be in the same file if you followed
the example above.  If you protected your private key with a password (a good idea, but turned off
by `-nodes`), give it to Postman.

![Tell Postman which client cert to use](assets/postman_client_cert.png "Tell Postman which
client cert to use")

Now Postman will use that certificate when it talks to Command Centre.  If you put the certificate's
thumbprint on the REST Client item with the API key Postman is using, you can turn on pinned
certificates in the server properties and Postman will still be able to connect.

You can leave Postman using this certificate no matter whether CC has pinned certificates turned off
or on:  it does no harm.

### Chrome

When you first try to connect to Command Centre using Chrome it will give you a list of certificates
in the store and ask you which to use.  Select the one you just put there.

### wget

<pre>
wget                                                                          \
    --no-check-certificate                                                    \
    --certificate=<i>your_pem_file</i>                                               \
    --header="Authorization: GGL-API-KEY <i>your-API-key</i>"                        \
    https://localhost:8904/api
</pre>

The `--no-check-certificate` turns off client-side checking of the server certificate.

Careful:  my version of wget does not complain if it cannot read the certificate file.

### curl
<pre>
curl                                                                          \
    --verbose                                                                 \
    --insecure                                                                \
    --cert <i>your_pem_file</i>                                                      \
    --header "Authorization: GGL-API-KEY <i>your-API-key</i>"                        \
    https://localhost:8904/api
</pre>

The `--insecure` turns off client-side checking of the server certificate.

I found `--verbose` necessary to see any error codes.

----------------------------------------------------------------------
<!-- S19 -->
# Server-side certificates
Clients may refuse to talk to a server that offers a certificate that is not carrying a signature
from one of the internet's signing authorities.  One that has not been paid for, in other words.
Usually the client is completely under the developer's control because it is their own application
and they can instruct it to skip the server certificate check, as you told Chrome and Postman to do
earlier.

If you will pardon a very brief dive into source code, here is one way of achieving that in a C#
client:

    ServicePointManager.ServerCertificateValidationCallback = delegate (
        object s, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        { return true; };

If you do not have control of the client application, or you wish to check the server certificate
(which is an advisable cyber-security move), here are a couple of approaches.

You only need one of these.

## Pin the server certificate on the client

Go to Server Properties, Web Services, Manage Certificates, and click View on whichever type of
certificate you are using.  Go to the Details tab in the window that appears, then choose Copy to
File.  You have a few choices for the format to export it to.  DER is good for Windows machines, but
a PFX – if that option is enabled – might be more widely accepted on non-Windows systems.  If you
are ever asked if you want to export the private key, _just say “no”_.

Once you have your certificate file on disk, copy it to the client machine.  Provided you didn't let
a private key get in there, it is not a secret.

How you install it on the client depends on the client.  On a Windows box, it may be as simple as
double-clicking it.  The Certificate Import Wizard will ask you where to install it:  you probably
want Trusted Root Certificate Authorities.  That is a bit of a sledgehammer, because it makes not
only your REST client but every client on that host trust that certificate.  Plus, they will trust
any other certificate signed by it.  But it will get you going.

## Buy a signed certificate for the server
If that method does not suit, perhaps because you do not have control of the clients, you could buy
a “real” certificate for your CC server.  One drawback is that signatures eventually expire,
requiring you to do this every year or three.  Another is that you must buy a new certificate if you
change the name of your server – so use a DNS alias.

This is nothing new for REST APIs:  it is the process that every web site owner goes through.  If
you want to sell scones and Toby mugs from www.itsabritishthing.com, for example, you:

1. generate a certificate for www.itsabritishthing.com,
3. generate a certificate signing request (a CSR) from that certificate,
2. decide which signing authority to use,
4. send the CSR to that signing authority, with your credit card details and proof that you own
   itsabritishthing.com,
5. wait, then
6. use the signed certificate on your web server.

That is exactly what you will need to do for Command Centre.  Start with the DNS alias for your
server instead of www.itsabritishthing.com.  The next few steps are a Googling exercise for the
reader because they depend on which authority you choose.  Finish with a simple process covered in
the section called “Replacing the web service certificate” of the Configuration Client's user guide.
Briefly, it is:

1. Go to Server properties, Web Services, REST API section Manage Certificates, and
2. change the radio box to Custom Certificate,
3. click Import, and
4. browse to your certificate file.

At time of writing, Gallagher Group has no association with www.itsabritishthing.com.

----------------------------------------------------------------------

<!-- S20 -->
# Other Command Centre items
Version 8.00 added fence zones, access zones, alarm zones, doors, macros, and outputs (relays and
LEDs) under two licences.  The RESTStatus licence lets you see their status and some basic
configuration, and the RESTOverrides licence lets you send overrides to them.  So you can open
doors, run macros, disarm fence and alarm zones, toggle outputs, and so on.  Version 8.10 added
inputs (switches).  Version 8.30 added a method `/api/items/updates` which lets you monitor several
items with one connection.  Version 8.50 added operator groups, schedules, and day categories.

Note that the REST API does not let you create, edit, or delete any of these items except schedules.
The configuration client is still the place for that.

Each of those item types has its own controller, its own block of links in `/api`, and its own
section in the developer documentation.  Schedules, day categories, and the items with status like
zones and hardware have their documentation under "Status and Overrides".  Because the
`items/updates` method is on the items controller it in with Alarms and Events.  Operator groups are
in with cardholders.

As an example of how to use these APIs, here is how you would list all your doors and get the link
to open one of them:

    GET /api
    // You would find and use the URL at features.doors.doors.href, which in 8.30 is:
    GET /api/doors
    // To search for one door use the 'name' parameter:
    GET /api/doors?name="Greendoor"
    // Or, to only get the override links because all you want to do is open it, you'd use this:
    GET /api/doors?name="Greendoor"&fields=commands

## Overriding items
To send an override to an item you make an HTTP POST to a URL that you get from the item itself.

The output from the last example above, that requested the `commands` block of the door called
'Greendoor', is:

    "results": [
        {
            "commands": {
                "open": {
                    "href": "https://localhost:8904/api/doors/507/open"
                },
                "free": {
                    "href": "https://localhost:8904/api/access_zones/533/free"
                },
                "freeUntil": {
                    "href": "https://localhost:8904/api/access_zones/533/free"
                },
                "freePin": {
                    "href": "https://localhost:8904/api/access_zones/533/free_pin"
                },
                "freePinUntil": {
                    "href": "https://localhost:8904/api/access_zones/533/free_pin"
                },
                "secure": {
                    "href": "https://localhost:8904/api/access_zones/533/secure"
                },
                "secureUntil": {
                    "href": "https://localhost:8904/api/access_zones/533/secure"
                },
                // ... ten more commands omitted for brevity ...
                "cancel": {
                    "href": "https://localhost:8904/api/access_zones/533/cancel"
                }
            }
        }
    ]

Normally a search would return an ID, href, and name, and it would not return that block of
commands, but we turned that on its head by using the `fields` query parameter to request the
`commands` block and nothing else.  Each of the objects inside it is a named command containing an
href which, when you POST to them, sends an override to the item.  For example, if that was a door
on your system and you pasted the URL from `commands.open` into Postman, and POSTed it, the unlock
relay on that door would fire.

Each item type has a different set of commands you can send it.  They vary in type and number:
outputs have four and access zones have 21.  Most of those access zone overrides are also available
on the zone's doors, for convenience.

Overrides don't need anything in the body of the POST, but those with 'Until' in the name of the
command will use a timestamp if you send it:

    POST /api/access_zones/533/free
    {
        "endTime": "2020-03-06T00:00:00Z"
    }

That example would put the door's entry access zone in free mode until midnight March 6.

## Status flags

Just as each item type has its own commands, each also has its own set of status flags.  A door can
be open or closed, for example, while an access zone can be secure or free.  Each also has its own
set of flag rules that they will always follow.  Doors, inputs, and outputs are quite simple but
fence zones have half a dozen rules thanks to the voltages they deal with.

The developer documentation clearly lays out all the status flags items can return, and their rules.
For example, here is part of the section on outputs:

If the output is online, its `statusFlags` field may contain one or more of these flags:
* `relayStateUnknown` means the controller does not know what the output should be doing.
* `closed` means the output relay is closed.
* `open` means the output relay is open.
* `pulsed` means the relay's change in state is momentary.
* `switchingDisabled` means switching this output is disabled.
* `overridden` means the output is under the effect of an override.

If and only if the output is online, one of 'relayStateUnknown', 'closed', or 'open' will appear.
Of the above, only 'overridden' can appear when the output is offline.

The above tells you that the first flags you should look for are 'relayStateUnknown', 'closed', and
'open'.  If none of those is in the flag set then your output is offline.  Other flags will tell you
what the problem is, if you want to go deeper, but it is probably enough for your integration to
know that the output's state is uncertain and it should subscribe to updates in case that changes.

At last count there were eleven status flags common to all items.  Some are not so serious, like the
flags that indicate the item is shunted (muted) or is not fully configured yet.  Others indicate an
actual problem like a network outage, a cable fault, or a service not running.  The developer
documentation covers them all (search for 'abnormal status').

End quote.  There is a lot more on the topic in the reference documentation.

## Subscribing to updates (one item, pre-8.30) TODO

This section TODO.  What follows is a broad outline of what the section should contain.

GET the `updates` link on an item's details page.  It is a long poll, so the server won't respond
until it has something for you (or it times out after about 50s).  Then stay up to date by entering
a loop GETting the `next` link.

Why use this one instead of the one below?

* You're not running 8.30 yet, or
* it's slightly easier if you're monitoring only one item (though that is debateable), or
* your client wants to wait longer than 30s between GETs.

## Subscribing to updates (many items, 8.30+) TODO

A rough outline:  GET `/api` then POST a document to the link at `features.items.updates` (which is
`/api/items/updates` in 8.30, but may change, which is why you should use the page at `/api`).

The body of your POST should look like this:

    {  "itemIds": ["508", "526"]  }

Those numbers are item IDs.  Even though they look like integers they must be in quotes because in
the future they could contain alphas.  Place as many in the array as you like.  We tested 1,000
without it affecting performance.

The POST will return with the status of all your items and a next link.  GET that link, and keep
GETting it in a loop to stay up to date.  The calls will block if there are no changes to report.
Sleep between calls to avoid tight loops.  But not longer than 30s, otherwise the server will drop
your session, thinking you have walked away.

The first GET will return the same states that the POST did, which seems redundant, but that is just
the way it is.  Just keep looping.

Why use this one instead of the per-item updates?

* You want to monitor more than one item per client thread.

## Schedules and day categories TODO

When updating a schedule you must replace its entire list of day categories and times.  This is
quite different from how you normally update lists via this API.  The JSON schema allows room for us
to accept the normal style as a future enhancement, but in 8.40 you must replace all a schedule's
schedules at the same time.  That suits our target use-case, which was for an integration to
download the schedule, de-serialise it into an object model, change some part of it, then
re-serialise and upload it back.

----------------------------------------------------------------------

# Appendix:  privilege table

This is not the complete list!  See the topic 'Which Operator Privileges you require' in the
Configuration Client's online help for more.

Remember that privileges lie on divisions, not on items, so when this table says you need a
privilege on some item, take it to mean that you need that privilege on the division containing that
item, or one of that division's ancestors.

<!-- This is very unpleasant editing.  The HTML isn't that attractive either, with no vertical
alignment, and slightly wonky line spacing around unordered lists.  Suggestions welcome.

Believe it or not there is some order to this.  Please don't dump your stuff on the end.

-->

|Goal|Privileges required|
|---|---|
|View cardholder data at `/api/cardholders` and `/api/cardholders/id` except notes and operator fields. |'View Cardholder' or any of the privileges that allow editing a cardholder, on the cardholder's division. |
|View all cardholder data|'View Cardholder' or any of the cardholder editing privileges on the cardholder's division, plus 'View Cardholder Notes' reveals notes, 'View Lockers and Assignments' adds locker detail.|
| Create cardholders, but not modify them.|'Create Cardholders' on the cardholder's division.|
|Create and edit cardholders, except their notes and operator settings.|'Create and Edit Cardholders' on the cardholder's division.|
|Edit cardholders, except their notes and operator settings.|'Edit Cardholders' on the cardholder's division.|
|Edit cardholder notes.|One of the privileges that lets you edit cardholders as well as either of 'Add Cardholder Notes' or 'Edit Cardholder Notes' on the cardholder's division.  It is different in the thick clients:  there, one of the last two is enough.|
|Modify cardholder group memberships.|One of the privileges that lets you edit cardholders on the cardholder's division plus 'Modify Access Control' on the group's division. <br />'Modify Access Control' on the group's division is enough in the thick clients.|
|Change a cardholder's location.|'View Cardholder' on the cardholder, and 'Manage Cardholder Location' on the target access zone's division, when you are moving the cardholder into an access zone, otherwise any division, when you are moving the cardholder outside the system.<br />By the way:  collecting access zones normally requires the RESTStatus licence, but there is a variant of that call that returns just the zones your operator is allowed to move cardholders to that only requires the RESTCardholders licence.|
|Assign a card to a cardholder.|One of the three privileges that lets you edit cardholders on the cardholder's division and on the card type's division.|
|View assignable card types at `/api/card_types/assign`|One of the 'edit cardholder' privileges on the card type's division.|
|View card types at `/api/card_types`|'View site' or 'configure site' on the card type's division.  The privileges that let you create or edit cardholders also reveal PIV types.'|
|Change locker assignments.|One of the privileges that lets you edit cardholders on the cardholder's division plus 'Manage Locker Assignments' on the locker's division. <br />'Manage Locker Assignments' on the locker's division is enough in the thick clients.|
|Disable a card.|One of the privileges that lets you edit cardholders on the cardholder's division. <br />The 'Disable Card' privilege has no effect on current versions of the REST API. <br />In the thick clients you do not need edit privileges on the cardholder if you have 'Disable Card'.|
|De-authorise a cardholder.|'De-authorise Cardholder' or one of the privileges that lets you edit cardholders on the cardholder's division.|
|Edit a relationship between cardholders.|One of the privileges that lets you edit cardholders on the cardholder's division and on the role's division.|
|View a cardholder's operator configuration|'View Operators' or one of the privileges that let you modify an operator, such as 'Edit Operators' or 'Enable/disable Operator'|
|View operator groups| 'Edit Operator Groups' or 'View Operator Groups' |
|Change a cardholder's operator groups | 'Modify Operator Group Membership' |
|View PDF definitions at `/api/personal_data_fields`|'View...' or 'Edit Personal Data Definitions' on the PDF's division.|
|View events at `/api/events`|'View Events and Alarms' or any of the privileges that allow processing alarms, on the division of the source of the event or alarm.|
|Acknowledge, process, or mark alarms as viewed.|'Edit Alarms' on division of the source of the event or alarm.|
|Create new events (8.10+)|'Create Alarms and Events' on the division of the source of the event, if you set a source, or any division if you did not set a source.|
|List access groups.|'View access groups' or 'edit access groups' on the access group's division.|
|List competencies.|'View site' or 'Edit site'.|
|Receive schedule hrefs in an access group|'View Schedules' on the schedule's division. <br />'View site', 'Configure site', and 'Edit site' will not do it.|
|List access zones and receive their hrefs in other results|'Edit site', 'View site', or 'Override' on the access zone's division.|
|Override an access zone's mode.|'Override' on the zone's division.|
|List alarm zones|'Edit site', 'View site', or 'Override' on the alarm zone's division.|
|List doors|'Edit site', 'View site', or 'Override - open door' on the door's division.|
|Override doors|'Override - open door' on the door's division.|
|List fence zones|'Edit site', 'View site', or 'Maintenance override' on the fence zone's division.|
|Override fence zones|'Maintenance override' on the fence zone's division.|
|List inputs|'Edit site', 'View site', 'Maintenance override' on the input's division.|
|List macros|'View site', 'Run macros', or 'Schedule and run macros' on the macro's division.|
|List outputs|'Edit site', 'View site', or 'Override' on the output's division.|
|List day categories|'Configure site', 'Edit schedules', 'View site'.  Day categories are divisionless, so having one of those privs on any division is enough. <br />'View schedules' is true to its word:  it will not show you day categories.|
|List schedules |'View schedules', 'Edit schedules', 'Schedule access zone' (though the last one only gives you access to access zone schedules, not the other five types).|
|Create, edit, and delete schedules.|'Edit schedules'.|
|List elevator groups|'Modify Default Floors' is probably the one you want.  'View site' lets you see elevator groups, but might not let you use them on a cardholder.|
|Set a cardholder's default floors (for calling elevators)|'Modify Default Floors'|
|Run a macro at `/api/macros/id/run`|'Run Macros' or 'Schedule & Run Macros' on the macro's division.|
|Shunt or unshunt an item.|'Maintenance Override' on the item's division.  'Override', which is good for most other overrides, is not enough to shunt or unshunt an item.|

|View a division's visitor management configuration, and view receptions| 'View Site', 'Edit Site', 'View Visits', 'Edit Visits', or 'Manage Receptions'|
|View a visit|'View' or 'Edit Visits'.  'Manage Receptions' will not do it.|
|Modify a visit|'Edit Visits'.  'Manage Receptions' will not do this either.|

<!-- S22 -->
----------------------------------------------------------------------
# Appendix:  Features and licences

## Alarms and events
7.80 allows reading and writing unprocessed alarms.  Clients can read all their fields, mark them as
viewed, add comments, acknowledge, and ultimately process them.

7.80 allows reading events.  Clients can see all fields, including these related items:

* cardholder, entry/exit zone, division,
* (in 8.00) the source item, and the operator and access group on head-end events (i.e., those that did not come from a controller),
* (in 8.30) the door on guard tour events, and
* (in 8.40) the item that an operator modified.

In 8.30 the following are absent from the list of items related to an event:  locker bank and
locker, door (unless it is a guard tour event), missing competency, car park, and car park space.
In practice that is rarely a problem since those items are often the event's source, and will
therefore be in the source block.

You need RESTEvents in your licence for all the above.

8.10 allows creating external events with the RESTCreateEvents licence.  Clients can use the usual
item types as the source of the event and can attach one of each of these as related items:

* cardholders,
* operators,
* entry access zones,
* access groups,
* lockers and locker banks, and
* doors.

## Cardholders and supporting items

7.90 allows most administrative functions on cardholders, including full credential maintenance.

It also gives read-only access to supporting items:

* access groups,
* competencies,
* card types,
* roles,
* lockers,
* (in 8.10) PDF definitions,
* (in 8.50) default elevator floors, and (hopefully) operator privileges.

8.20 allows moving cardholders between access zones.  To support that it added a call to the access
zones controller that requires the cardholders licence, not RESTStatus as the other access zone
calls do.

8.30 allows subscribing to cardholder changes, for integrations that use Command Centre as a source
of users.

8.40 shows an access group's access zones, Salto items, and privileges (there are 20).  In the
Access Group window in the Configuration Client these are the 'Access', 'Salto Access', and
'Privileges' tabs.  These are all read-only fields.

8.50 adds views of operator groups, receptions, and visitor management settings, and read-write
access to visits and cardholders' operator and elevator settings.

Car parks remain on the roadmap.

These cardholder functions require the RESTCardholders licence.  8.20 added lockers and locker banks
to the RESTStatus licence as well, minus the cardholder information.

## Non-cardholder items

8.00 allows read access to basic configuration, status, and all overrides, to:

* access zones, alarm zones, and fence zones,
* doors,
* macros, and
* outputs and (in 8.10) inputs.

You will need the RESTStatus licence for the GETs and RESTOverrides for the override POSTs.

8.20 added lockers, previously only visible with the RESTCardholders licence, to the RESTStatus
licence.

8.30 added the ability to monitor more than one item per connection.

8.50 allows read access to day categories and partial read-write access to schedules.  You can
manage the day categories and times on a schedule, but not which items it affects.

Day categories are divisionless, which lead to a slight change in the `/items` controller:
divisionless items did not appear there before 8.50; now they do (subject to privilege checks, of
course).

8.50 allows viewing elevator groups.

There are no functions for creating, configuring, or removing those item types.

