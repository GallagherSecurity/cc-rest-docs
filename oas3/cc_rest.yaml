## Automatically generated.  Do not edit.
openapi: '3.1.0'

x-common-blocks:

  - &CONNECTEDCONTROLLER
    type: object
    description: |
      This block describes this item's hardware controller.

      Retrieving it takes a little more time than the other fields so only ask for it if you
      need it.

      Added in 8.50.
    properties:
      name: {type: string, example: "Fourth floor C7000"}
      href:
        type: string
        format: uri-reference
        example: "https://localhost:8904/api/items/508"
        description: |
          This is the REST API's identifier for the hardware controller.  It is only an
          identifier, not a usable URL, because there is no interface for hardware
          controllers.  GETting the URL will return a 404.
      id:
        type: string
        description: |
          An alphanumeric identifier, unique to the server.  This is the ID to use in the `source`
          parameter of [event filters](events.html#operation--api-events-get).
        example: "634"

  - &CONNECTEDCONTROLLER_BRIEF
    type: object
    description: |
      This block describes this item's hardware controller.  Retrieving it takes a little more time
      than the other fields so only ask for it if you need it.

      Added in 8.50.

  - &EVENTTYPE_DESC |
      ID and name of the event's or alarm's type.  There is a long list of them at
      [/events/groups](#operation--api-events-groups-get).

      Unlike the `type` field, this has the same format in an event as it does in an alarm.

      Added in 8.90.  Because it is a new field, it does not appear by default.  Ask for it using
      the `fields` parameter.

  - &ID_DESC |
      An alphanumeric identifier, unique to the server. This is the ID to use in the `source`
      parameter of [event filters](events.html#operation--api-events-get) and in the body of [status
      subscriptions](events.html#status-subscriptions) when you are interested in events originating at this item.

  - properties: &UPDATES_PROPS
      href:
        type: string
        format: uri-reference

  - &UPDATES_DESC |
      Follow the URL in the href inside this block to receive the item's current status, then follow
      the `next` link in the results to long poll for changes to that status.

      This method only monitors one item at a time.  To monitor the status of many items, use the
      [status-monitoring routes](#?route=post-/api/items/updates).

      Update pages take the same `fields` parameter as summary and details pages.  You should use
      that to request all the fields you need in the update.

  - &NOTES
    type: string
    example: "Multi-line text..."
    description: |
      Because of their potential size, notes are only available by request.  Use the 'fields'
      parameter:

      `?fields=defaults,notes,...`

  - &SHORTNAME
    type: string
    maxLength: 16
    example: "Short text"
    description: |
      Short names are not displayed by default.  You must ask for them using the
      'fields' parameter:

      `?fields=shortname,...`.

  - description: &FIELDS_SUM_DESC |
      This instructs the server to return only these fields in the search results.  The values you can list are the same as the field
      names in the details page.  Using this you can return everything on the summary page that you
      would find on the details page.  Separate values with commas.

      Use the special value `defaults` to return the fields you would have received had you not given
      the parameter at all.  Obviously only do that if you have more to add.

      Treat the string matches as case-sensitive.

      In v8.00 you will receive the href and internal ID even if you did not ask for them.  In 8.10
      and later you will only get what you asked for.  If you are going to send the `fields`
      parameter and need the href or ID, be explicit.
     
  - description: &FIELDSDESC_SUM_810 |
      This instructs the server to return only these fields in the search results.  The values you can list are the same as the field
      names in the details page.  Using this you can return everything on the summary page that you
      would find on the details page.  Separate values with commas.

      Use the special value `defaults` to return the fields you would have received had you not given
      the parameter at all.  Obviously only do that if you have more to add.

      Treat the string matches as case-sensitive.

  - description: &FIELDS_DET_DESC |
      This instructs the server to return only these fields in the details page instead of the default set.  The values you can list
      are the same as the field names you would see in the results.  Use it to cut back on the size
      of the response.  Separate values with commas.
     
      Treat the string matches as case-sensitive.
     
      In v8.00 you will receive the href and internal ID even if you did not ask for them.  In 8.10
      and later you will only get what you asked for.  If you are going to send the `fields`
      parameter and need the href or ID, be explicit.

  - &FIELDSDESC_DET_810
    description: |
      This instructs the server to return only these fields in the details page instead of the default set.  The values you can list
      are the same as the field names you would see in the results.  Use it to cut back on the size
      of the response.  Separate values with commas.
     
      Treat the string matches as case-sensitive.

  - description: &FIELDS_DET_810_DESC |
      This instructs the server to return only these fields in the details page instead of the default set.  The values you can list
      are the same as the field names you would see in the results.  Use it to cut back on the size
      of the response.  Separate values with commas.
     
      Treat the string matches as case-sensitive.
     
  - description: &FIELDS_SUMONLY_DESC |
      This instructs the server to return only these fields in the search results.  The values you can list are the field names in the
      schema definitions in this document.  Separate values with commas.

      Use the special value `defaults` to return the fields you would have received had you not given
      the parameter at all.  Obviously only do that if you have more to add.

      Treat the string matches as case-sensitive.

  - &SERVER
    readOnly: true
    type: string
    example: "ruatoria.satellite.int"
    description: |
      If you are running a multi-server installation and this item is homed on a remote server, this
      field will contain the name of that server.  This field is missing from items that are held on
      the machine that served the API request.  Added in 8.40.

      This is a read-only field.  The server will ignore it if you send it.

  - &SERVER_DESC |
      If you are running a multi-server installation and this item is homed on a remote server, this
      field will contain the name of that server.  This field is missing from items that are held on
      the machine that served the API request.  Added in 8.40.

      This is a read-only field.  The server will ignore it if you send it.

  - description: &STATUSFLAGS_DESC |
      The search and details pages do not return status flags by default, because an item's status
      is unknown until something is monitoring it.  If you want status flags on the search and
      details pages you must ask for them using the `fields` parameter, but our advice is to monitor
      them using [status subscriptions](events.html#status-subscriptions) if you are running 8.30 or
      later, otherwise the item's `updates` link.  See the [item status](#topic-Item-status) section
      for a full description of how to stay up to date with item status, and this item's
      introduction in the Operations section for what flags this item might return and what they
      mean.

  - &STATUSTEXT
    description: |
      This field contains a translated multi-line human-readable description of the item's status.
      See the `statusFlags` field for notes on when you should ask for this field and how to keep it
      up to date.
    type: string
    example: "Controller offline."
  - &STATUSTEXT_DESC
      This field contains a translated multi-line human-readable description of the item's status.
      See the `statusFlags` field for notes on when you should ask for this field and how to keep it
      up to date.
  - &STATUS
    description: |
      This field contains the `statusText` field with line endings turned into spaces to make a
      one-line string.  See the `statusFlags` field for notes on when you should ask for this field
      and how to keep it up to date.
    type: string
    example: "Controller offline."
  - &STATUS_DESC
      This field contains the `statusText` field with line endings turned into spaces to make a
      one-line string.  See the `statusFlags` field for notes on when you should ask for this field
      and how to keep it up to date.

  - &UPDFIELDS
    in: query
    required: false
    description: |
      This instructs the server to return these fields in the update, instead of the default set.  Note that removing fields also
      saves you from hearing about updates to those fields.

  - &UPDFIELDS_DESC |
      This instructs the server to return these fields in the update, instead of the default set.
      You will not hear about updates to fields you do not list.

  - &UPDFIELDSENUM
    schema:
      type: string
      enum: [ status, statusText, statusFlags ]

  - &UPDFIELDS_SCHEMA
      type: string
      enum: [ status, statusText, statusFlags ]
     

  - &BADGE_BETA
    color: red
    label: Beta              
    name: Beta               

  - &BADGE_930
    color: blue
    label: "9.30"            
    name: "9.30"
      
  - &MACROFIELDS
    in: query
    required: false
    schema:
      type: string
      enum: [href, id, name, description, division, commands, notes, updates]

  - &MACROFIELDS_SCHEMA
      type: string
      enum: [href, id, name, description, division, commands, notes, updates]

  - &OUTPUTFIELDS_SCHEMA
      type: string
      enum: [href, id, name, shortName, description, division, commands, connectedController, statusFlags, statusText, status, notes, updates]

  - &409CH
    description: |
      The cardholder is locked for editing by another operator.  The body of the response will
      tell you which operator is holding the lock.

  - &CARDMOBILE
    number: Nick's mobile

    status:  {value: "active"}
    type: {"href": "https://host.com:8904/api/card_types/654"}
    from: 2017-01-01T00:00:00Z
    until: 2018-01-01T00:00:00Z
    invitation:
      email: nick@example.com
      mobile: "02123456789"
      singleFactorOnly: true

  - &CARDMOBILE2
    number: Nick's other mobile

    status:  {value: "active"}
    type: {"href": "https://host.com:8904/api/card_types/654"}
    invitation:
      email: nick@example.com
      mobile: "02198765432"
      singleFactorOnly: true

  - &CSC
    type: string
    description: |
      This is required when creating a PIV or PIV-I card.  The API will reject your request if this is
      missing or not a Base64-encoded certificate, but it will not validate the certificate itself.

      This example is shortened to fit on screen.  Real certificates are at least a thousand
      characters.
    example: "MIIE[...]Kltk="

  - &CAC
    type: string
    description: |
      This contains the CAK, which is necessary for the secure use of contactless cards.  It is
      not required for contact cards.

      Optional when creating a PIV or PIV-I card.  The API will reject your request if this is
      present and not a Base64-encoded certificate, but it will not validate the certificate itself.

    example: "MIIE[...]e5mE="

  - &PAC
    type: string
    description: |
      This is required when creating a PIV or PIV-I card.  The API will reject your request if this is
      missing or not a Base64-encoded certificate, but it will not validate the certificate itself.
    example: "MIIE[...]wkrp"

  - &FINGERS
    type: string
    description: |
      If you send this when creating a card, it should be the cardholder's fingerprints contained in
      the card's Cardholder Fingerprints data object with the error detection code removed:  the
      whole CBEFF structure including the CBEFF_HEADER, CBEFF_BIOMETRIC_RECORD, and
      CBEFF_SIGNATURE_BLOCK components.  Refer to Section 9 of NIST Special Publication 800-76-2:
      Biometric Data Specification for Personal Identity Verification.

      It is optional.  The API will check that this is Base64, but will not verify that it is
      valid biometric data.

    example: "N7[...]Shpd="

  - &404ENC
    description: |
      The cardholder does not exist or is not visible to the operator, or that card is not on the
      cardholder.
    
x-zzztagGroups:
  - name: Operations
    tags: [ Access Groups, Access Zones, Alarm Zones, Card types, Cardholder changes, Cardholders, Competencies, Day Categories, Lockers, Operator Groups, PDF definitions, Receptions, Redactions, Schedules, Visits ]
  - name: Schemas
    tags: [ Schema Definitions ]

components:

  examples:

    CardholderPATCHCardMobileExample:
      description: |
        This is an example of what you would send to add two mobile credentials to an existing cardholder.

        `type` is the only compulsory field.  It must contain an href to the card type of the new
        mobile credential.

        The so-called card 'number' on a mobile credential does not need to be numeric.

        The `status` block is optional.  Provide a field `value` inside it set to one of the valid
        starting states for the mobile credential.  If you omit it, the credential will start in the
        default state.

        `invitation` is a block containing fields that describe how Command Centre should set about
        registering the mobile device.

        If you specify `mobile` you must also supply `email`.  If you give neither, Command Centre
        will not send an invitation to the cardholder.

        `singleFactorOnly` defaults to false, which is the recommended setting.  See the [card
        detail](#definition-Cardholder-card) for more.

      value:
        firstName: "Nick"
        cards:
          add:
            - *CARDMOBILE
            - *CARDMOBILE2

    CardholderPOSTCardMobileExample:
      description: |
        This is an example of what you would send to create a new cardholder with two mobile credentials.

        `division` and either `firstName` or `lastName` are required on a new cardholder, so this
        example includes those.

        `type` is the only compulsory field in the `cards` blocks.  It must contain an href to the card
        type of the new mobile credential.

        The so-called card 'number' on a mobile credential does not need to be numeric.

        The `status` block is optional.  Provide a field `value` inside it set to one of the valid
        starting states for the mobile credential.  If you omit it, the credential will start in the
        default state.

        `invitation` is a block containing fields that describe how Command Centre should set about
        registering the mobile device.

        If you specify `mobile` you must also supply `email`.  If you give neither, Command Centre
        will not send an invitation to the cardholder.

        `singleFactorOnly` defaults to false, which is the recommended setting.  See the [card
        detail](#definition-Cardholder-card) for more.

      value:
        firstName: "Nick"
        division: { href: https://host.com:8904/api/divisions/2 }
        cards:
          - *CARDMOBILE
          - *CARDMOBILE2

    CardholderPATCHCardPhysicalExample:
      description: |
        This is a minimal object for giving a cardholder a new card, containing nothing more than
        the card type.  See the [card detail](#definition-Cardholder-card) for other fields you can
        (and probably should) use, such as the card's issue level and from/until dates.

        `type` is the only compulsory field in a new card. It must contain an href to the card type
        of the new card.

        We also set this cardholder's first name, just for the sake of illustration.

      value:
        firstName: "Nick"
        cards:
          add:
            - type:
                href: "https://host.com:8904/api/card_types/600"

    CardholderPOSTCardPhysicalExample:
      description: |
        This is a minimal object for creating a cardholder with one card, containing the only
        required fields for a cardholder (name and division) and the only required field for a card (the card
        type).  See the [card detail](#definition-Cardholder-card) for other fields you can use,
        such as the card's issue level and from/until dates.

        `type` is the only compulsory field in a new card. It must contain an href to the card type
        of the new card.

      value:
        firstName: "Nick"
        division: { href: "https://host.com:8904/api/divisions/2" }
        cards:
        - type:
            href: "https://host.com:8904/api/card_types/600"

    PIVCardCreateExample:
      description: |
        This example, when placed inside the `cards` array of a
        [POST](cardholders.html#operation--api-cardholders-post) or the `cards.add` array of a
        [PATCH](cardholders.html#operation--api-cardholders--id--patch), would create a PIV
        credential and assign it to the cardholder created by the POST or identified by the address of
        the PATCH.  Consult those methods for the JSON you need to wrap around this example.

        A PIV-I example would have a different style of FASC-N, and a card number to match.
      value:
        number:
          example: "47000256001337111234567890199991"
          type: string
          description: |
            Required.

            For a PIV card, this is the FASC-N.

            For a PIV-I card, this is the decimal representation of the GUID in the CHUID, and must
            not be the same as the FASC-N.

            The server ignores hyphens here, so you can send back the same number you received from a
            GET.
        status:
          description: |
            Optional, but when controlling physical access you should be explicit rather than relying
            on a default.  Set the `value` field inside it to either 'active' or 'disabled
            (manually)'.  Case insensitive.

            You will not be able to activate a card if its PIV status (inside the `pivdata` block)
            prevents it.
          type: object
          example: { value: active }
        type:
          description: |
            Required.  This should be the href of the built-in PIV/PIV-I card type, that your
            application found using the process [in the introduction](#finding-the-piv-card-type).
          example: {href: "https://host.com:8904/api/card_types/244"}
        pivData:
          description: |
            This block contains all the PIV-specific fields.  Everything outside this block, including
            the number, status, and type, is common to all types of Command Centre cards and credentials.
          $ref: '#/components/examples/PIVCardData'

    PIVCardUpdateExample:
      description: |
        This example, when placed inside `cards.update` array of a PATCH, would update a card.  The
        main cardholder API documentation shows where to send the PATCH and what else you can change
        with it.  This example only shows how to update the status (common to all credential types)
        and the PIV data.

        Specifically, the PIV status, because that is the only PIV-specific data you can change on a
        PIV card.  Everything else--the CHUID, certificates, and biometrics--are all fixed, once set.

        See the [PIV data schema](#definition-PIV-card-data) for when you should set the PIV status
        and what you can set it to.

      value:
        href:
          type: string
          format: uri-reference
          example: https://host.com:8904/api/cardholders/5398/cards/90e5d0d70
          description: |
            This is the href of the card you want to update, found in the `cards` array in the
            [cardholder detail](cardholders.html#definition-Cardholder-detail).
        status:
          description: |
            Optional.  If you omit both this and the PIV status, or omit this and set the PIV status
             to 'normal' or 'offline', the server will set this to 'active'.  Any other PIV status will
             cause the card to become inactive, regardless of what you put here.

            So you really only need to set this when you are changing the PIV status to 'normal' or
            'offline' but you want the card to remain disabled.  In that case, set `status.value` to
            'disabled (manually)'.
          type: object
          example: { value: "disabled (manually)" }
        pivData:
          description: |
            This can contain only one field when you are updating a PIV card, `pivStatus.type`.

            The [PIV card data schema](#definition-PIV-card-data) lists the values you can send.
          type: object
          example: {pivStatus: {type: "notChecked"}}

    PIVCardData:
      description: |
        This example, when placed inside one of the cards in the `cards` array of a POST or the
        `cards.add` array of a PATCH, would create a PIV card.  It contains all the PIV-specific
        fields on a credential.

        It is the same as the block you [receive from the API](#definition-PIV-card-GET) for an
        existing PIV card, minus `lastCheckTime`.

      value:
        chuid:
          description: |
            Required.  The FASC-N in the `chuid` block, and its relationship with the card number, is
            the only difference between PIV and PIV-I cards in Command Centre.
          $ref: '#/components/examples/CHUID'
        pivStatus:
          type: object

          description: |
            This PIV status is distinct from the card status, which is a different field outside the
            `pivData` block.

            It is optional.  If you omit it when creating a card, the card will be enabled with a
            status of "NotChecked", which is a perfectly valid operating status.  If Command Centre is
            doing periodic certificate validation, the status will eventually change (to 'normal', all
            going well).

            You should send this block only if you are doing your own certificate validation.  It must
            contain a field `type` set to one of these values, based on the result of your validation:

              - Normal
              - Offline
              - Revoked
              - Expired
              - CertInChainRevoked
              - CertInChainExpired
              - IssuerSigCertRevoked
              - IssuerSigCertExpired
              - NotTrusted
              - PolicyError
              - OtherError
              - NotChecked

            If you set it to any value except 'NotChecked, 'Normal', or 'Offline', Command Centre will consider the
            card invalid and deactivate it regardless of what you pass as the card status.  You, or
            Command Centre's periodic certificate validation, may validate the card again later.

          example: {type: Normal}
        contentSigningCert:
          *CSC
        cardAuthenticationCert:
          *CAC
        pivAuthenticationCert:
          *PAC
        fingerprints:
          *FINGERS

    CHUID:
      description: |
        This is an example CHUID block for a PIV card.  The only difference between this and a PIV-I
        card is the FASC-N.
      value:
        hash:
          type: string
          description: |
            This is the hash of the CHUID object, Base64-encoded.  For a 256-bit hash it
            should be 44 characters long including one `=` pad.  The API will reject a string that is
            not valid Base64, but it will not verify the hash.

            Required in versions up to 8.60.  Optional in 8.70 and later.
          example: "NSBvmBxA8zXz+dScJoYNLb96YMHEZXGghGirRJxWVhE="
        fascn:
          type: string
          description: |
            This is the FASC-N identifier.  You must supply it when creating a card.

            It must be the same as the card number on a PIV (not PIV-I) card.

            On a PIV-I card, it must not be the same as the card number (and for Federal PIV-I cards
            it will likely begin with fourteen nines).
          example: "47000256001337111234567890199991"
        orgIdentifier:
          type: string
          description: Optional.
          example: ""
        duns:
          type: string
          description: Optional.
          example: ""

    CardholderPOSTExample:
      description: |
        This is an example of a POST you could use to create a cardholder in a specific division and
        access group, with an access card, another cardholder as a supervisor, a competency, a student
        ID and a photo held in personal data fields, and two lockers.

        There are plenty more fields than shown in this example.  For a complete list please see the
        schema for the detailed [cardholder object](#definition-Cardholder-detail) that you receive
        from a cardholder href.

        In this example we are giving our new cardholder a disabled competency, set to enable in
        January 2019.

        The example shows that this cardholder will have cardholder 5398 performing role 5396.

        The example shows our cardholder receiving two lockers.

        The example shows our cardholder receiving a default floor for the first elevator group,
        with the Code Blue feature enabled in the second group.

      value:
        firstName: Algernon
        lastName: Boothroyd
        shortName: "Quartermaster"
        authorised: true
        division: { href: "https://host.com:8904/api/divisions/5387" }
        "@email": "user@sample.com"
        "@headshot": "/9j/4A...=="
        personalDataDefinitions: [ { "@email": { notifications: true } } ]
        cards:
        - type: {href: "https://host.com:8904/api/card_types/600"}
          pin: "153624"
        - type: {href: "https://host.com:8904/api/card_types/654"}
          number: "Nick's mobile"
          invitation:
            email: "nick@example.com"
            mobile: "02123456789"
        accessGroups:
          - accessGroup:
              href: "https://host.com:8904/api/access_groups/352"
            from: "2019-01-01T00:00:00Z"
        operatorGroups:
          - operatorGroup:
              href: "https://host.com:8904/api/operator_groups/523"
        competencies:
          - competency:
             href: "https://host.com:8904/api/competencies/2354"
            enablement: "2019-01-01T00:00:00Z"
        notes: ""
        notifications:
          enabled: true
          from: "2017-10-10T14:59:00Z"
          until: "2017-10-17T14:59:00Z"
        relationships:
          - role:
              href: "https://host.com:8904/api/roles/5396"
            cardholder:
              href: "https://host.com:8904/api/cardholders/5398"
        lockers:
          - locker:
              href:  "https://host.com:8904/api/lockers/3456"
          - locker:
              href:  "https://host.com:8904/api/lockers/3457"

        elevatorGroups:
          - elevatorGroup:
              href:  "https://host.com:8904/api/elevator_groups/635"
            accessZone:
              href:  "https://host.com:8904/api/access_zones/637"
          - elevatorGroup:
              href:  "https://host.com:8904/api/elevator_groups/639"
            enableCodeBlueFeatures: true

  parameters:

    description:
      name: "description"
      in: query
      required: false
      schema: {type: string}
      description: |
        Limits the returned items to those with a description that matches this string.  By default it
        is a substring match; surround it with double quotes `"..."` for an exact match.  A `_` will
        match any single character, and a `%` will match any substring.  With or without quotes,
        having either of these wildcards in the string will anchor it at both ends as though you had
        surrounded it with `"`.

        The search is always case-insensitive.  Results are undefined if you search for the empty
        string (`description=` or `description=""`).

        Search parameters are ANDed together.

    directDivision:
      name: "directDivision"
      in: query
      required: false
      schema:
        type:  array
        items:
          type: string
      description: |
        Restricts items to those whose division is in this list.

        Unlike `division=`, it does not follow ancestry.  That means it will limit the search to items
        that are directly assigned to the divisions you list, whereas `division` (without the
        `direct`) will also include items that are assigned to their descendants.

        List the IDs of the divisions you are interested in separated by commas.  Item IDs are short
        alphanumeric strings, not URLs.

        Because this is the first query parameter we added that contains a capital letter, this will
        be the first time you have had to think about case sensitivity.  `directDivision` works,
        `directdivision` does not.

        Results are undefined if you provide an ID that is not in the form of a division ID.

        Search parameters are ANDed together.

        Added in 9.20.

    division:
      name: "division"
      in: query
      required: false
      schema:
        type: array
        items:
          type: string
      style: simple
      description: |
        Limits the returned items to those that are in these divisions.

        That includes all the items in those divisions' child divisions, because Command Centre treats
        items as though they are also in their division's parent, and its parent, and so on up to the
        root division.

        Separate the IDs of the divisions you are interested with commas.  Item IDs are short
        alphanumeric strings, not URLs.

        Results are undefined if you provide an ID that is not in the form of a division ID.

        Search parameters are ANDed together.

    reception_fields:
      name: "fields"
      in: query
      required: false
      schema:
        default: [ defaults ]
        type: array
        items:
          type: string
          enum: [href, name, description, division, serverDisplayName, defaultVisitorType, notes]
      description: |
        Specifies the fields in the response.  The values you can list are the same in the search and
        details pages.  Using it you can return everything on the search page that you would find on
        the details page, plus the reception's notes.  Separate values with commas.

        Use the special value `defaults` to return the fields you would have received had you not
        given the parameter at all.  Add more after a comma.

        Treat the string matches as case sensitive.

    id:
      name: "id"
      in: path
      required: true
      schema:
        type: string
      description: "An internal identifier."

    secondary_id:
      name: "secondary_id"
      in: path
      required: true
      schema:
        type: string
      description: "An internal identifier."

    name:
      name: "name"
      in: query
      schema: {type: string}
      description: |
        Limits the returned items to those with a name that matches this string.  Without surrounding
        quotes or a percent sign or underscore, it is a substring match; surround the parameter with
        double quotes `"..."` for an exact match.  Without quotes, a percent sign `%` will match any
        substring and an underscore will match any single character.

        The search is always case-insensitive.  Results are undefined if you do a substring search for
        the empty string (`name=`).  You will receive no items if you search for those with no name
        (`name=""`), as all items must have a name.

        Search parameters are ANDed together.

    pdf_fields:
      name: fields
      in: query
      description: |
        Specifies the fields in the search results.  The values you can list are the same in the
        search and details pages.  Using it you can return everything on the search page that you
        would find on the details page.  Separate values with commas.

        Use the special value `defaults` to return the fields you would have received had you not
        given the parameter at all.  Add more after a comma.

        Treat the string matches as case sensitive.
      style: form
      explode: false
      schema:
        type: array
        items:
          type: string
          enum:
            - href
            - id
            - name
            - description
            - division
            - serverDisplayName
            - type
            - default
            - required
            - unique
            - sortPriority
            - accessGroups
            - regex
            - regexDescription
            - defaultAccess
            - operatorAccess
            - notificationDefault
        default: [ defaults ]

    pos:
      name: "pos"
      in: query
      required: false
      schema: {type: integer}
      description: Reserved for internal use.  You may see it in URLs you receive from the server, but you must never add it yourself.

    requested_by:
      name: "requested_by"
      in: query
      required: false
      schema:
        type: string
        default: [ none ]
      description: |
        Attributes this override to the cardholder with this ID rather than the REST operator.
        Privilege checks will use the operator as normal, but event monitors and reports will state
        that the person responsible for the override was the attributed cardholder, not the REST
        operator.  The REST operator will appear in a special mention in the event's details.

        First available in 8.70.  Versions older than 8.70 will ignore the parameter, leaving the
        override attributed to the REST operator.

    skip:
      name: "skip"
      in: query
      required: false
      schema: {type: integer}
      description: Reserved for internal use.  Do not add it to your queries.

    sort:
      name: sort
      in: query
      schema:
        type: string
        enum: [ id, name, -id, -name]
      required: false
      description: |
        Changes the sort field between database ID and name.

        If you prefix `id` or `name` with a minus sign (ASCII 45), the sort order is reversed.

        There are two very strong reasons to sort by ID:

        1. Sorting by name carries a risk of missing or duplicating objects if your result set spans
           multiple pages and another operator is editing the database while your REST client is
           enumerating them.  This is known as "page drift."  Sorting by ID does not carry that risk.
        2. Following a `next` link is _dramatically_ quicker when sorting by ID.

        We _strongly_ recommend sorting by ID.  In case you were still in doubt, we will do that by
        default in a future version of Command Centre.

        The server silently ignores anything except the options listed here.

    top:
      name: "top"
      in: query
      required: false
      schema:
        type: integer
        minimum: 1
      description: |
        Limits the results to no more than this many items per page.

        Older versions of Command Centre returned 100 items per page in the absence of this parameter.  That is acceptable for GUI
        applications that will only display the first page, but for integrations that intend to
        proceed through the entire database it causes a lot of chatter.

        8.70 and later versions will default to 1000 items per request.  This is about where a graph
        of throughput versus page size begins to level out.

    updates_fields:
      name: "fields"
      in: query
      required: false
      style: form
      explode: false
      description: *UPDFIELDS_DESC
      schema: *UPDFIELDS_SCHEMA

    token:
      name: token
      in: query
      required: true
      schema: { type: string }
      description: Token provided by the encoding-data response callback link.

  requestBodies:

    OverrideEndTime:
      description: |
        Put this in the body of override POSTs to set the time at which the override should cease.
        The API will reject the override if the string is not empty and it cannot parse it into a
        date-time, but it will treat the override as having no end time if you mis-spell 'endTime'
        or if you send a blank string.

        Command Centre computes an override's duration to a whole number of minutes with a minimum
        of one.  That means that a timed override will always end at a multiple of sixty seconds
        from the time the hardware receives the override request, which means the override will end
        within thirty seconds of the time you supplied here.  In versions older than 8.80, the
        discrepancy may be up to a minute.

        Careful observation of overrides submitted from the Configuration client and from the API
        will reveal that they use different rounding methods.  Be assured, both result in overrides
        ending within a minute of the requested time.

      required: false
      content:
        application/json:
          schema:
            type: object
            properties:
              endTime:
                type: string
                format: date-time
                example: 2018-07-31T00:00:00Z

  responses:
    "400badbody":
      description: |
        The server could not parse the POST parameters.  There could be a syntax error in your JSON.
      content: {}

    "403nolicence":
      description: |
        A server running 8.50 or earlier is missing the RESTStatus licence.  A server running 8.60
        or later is missing both the RESTStatus and RESTOverrides licences (having one is enough for
        this API call).
  schemas:

    CardholderRedaction:
      title: Cardholder redaction
      description: |
        These appear in an array in a cardholder object.  Each describes a redaction scheduled for the
        cardholder.

        A cardholder can have multiple event redactions pending, because they can operate on events
        from different periods, but since a cardholder redaction removes the cardholder item there
        can be only one.

      properties:
        href:
          type: string
          format: uri-reference
          description: |
            DELETE this URL to cancel this redaction.

            DELETE is the only verb you can use on this URL.  GET will always return a 404.

          example: "https://localhost:8904/api/cardholders/redactions/625"
        type:
          type: string 
          enum: [ normalEvents, cardholder ]
          description: |
            Whether this redaction is for cardholder events or cardholder information.
          example: "normalEvents"
        when:
          description: |
            When redaction is meant to happen.  This should be in the future.  If it is in the past,
            the service returns 400-Bad Request Invalid Start Time.

            Optional.  If it is absent, it means to do it asap.

          type: string
          format: date-time
          example: "2023-01-01T00:00:00Z"
        before:
          description: |
            For event redactions, do not redact any events after this time.  No effect on cardholder
            information redactions.

            Optional.

          type: string
          format: date-time
          example: "2022-01-01T00:00:00Z"
        status:
          type: string
          enum: [ pending, inProgress, cancelled, done, failed ]
          description: |
            The status of this redaction.
          example: "pending"
        redactionOperator:
          description: |
            A block containing the href and current name of the operator who scheduled the redaction.

          type: object
          example: {"name": "REST Operator", "href": "https://localhost:8904/api/items/100"}

    CardholderSearch:
      title: "Cardholder search"
      x-tags: [Cardholders]
      type: object
      properties:
        results:
          type: array
          description: An array of cardholder summaries.
          items:
            $ref: '#/components/schemas/CardholderSummary'
        next:
          type: object
          properties:
            href:
              type: string
              format: uri-reference
          description: The link to the next page.  Absent if you have retrieved them
            all.
          example:
            href: "https://host.com:8904/api/cardholders?skip=61320"
      description: "An array of cardholder summaries, and a `next` link for more."

    CardholderSummary:
      title: Cardholder summary
      type: object
      properties:
        href:
          type: string
          format: uri-reference
          readOnly: true
          description: |
            A link to a [cardholder detail](#definition-Cardholder-detail) object for this cardholder.
            This is Command Centre's identifier for this cardholder:  use it whenever you need to
            specify a cardholder in REST operations.
          example: "https://host.com:8904/api/cardholders/325"
        id:
          type: string
          description: |
            An alphanumeric identifier, unique to the server.  No API calls use cardholder IDs.

            Deprecated.  Use the href instead.
          readOnly: true
          example: "325"
        firstName:
          type: string
          example: Algernon
        lastName:
          type: string
          example: Boothroyd
        shortName:
          maxLength: 16
          type: string
          description: |
            If you supply a string that is too long when creating or updating
            a cardholder, Command Centre will truncate it.
          example: Q
        description:
          type: string
          example: Quartermaster
        authorised:
          type: boolean
          description: |
            This is called 'Cardholder Authorised' in the administrative clients.  If false, Command
            Centre will deny card access decisions for this cardholder.

            'authorised' is false by default.  If you want a new cardholder to open doors, be sure to
            set it to true in your POST.

            You need the 'Edit cardholders' privilege to set this true.  In versions prior to 8.80
            your operator also needed that privilege to set it false, but in 8.80 and later
            'De-authorise cardholder' is enough on its own.
          example: true
      description: |
        The cardholder search at `/api/cardholders` returns an array of these.  It is a subset of what
        you get from a cardholder's detail page at `/api/cardholders/{id}` (linked as the href in this
        object), to be more suitable for large result sets.

    CardholderDetail:
      title: Cardholder detail
      description: |
        [/api/cardholders/{id}](#operation--api-cardholders--id--get) returns one of these, and you
        submit [parts of one](#definition-Cardholder-POST-example) in a POST to create a cardholder.

        You may find it contains a block called `updates`.  This is reserved for future
        development and its behaviour will change in later versions of Command Centre.
      allOf:
      - $ref: '#/components/schemas/CardholderSummary'
      - type: object
        properties:
          lastSuccessfulAccessTime:
            type: string
            description: |
              The date and time of the last successful card event or operator-initiated movement
              (using a tag board or [this API](#operation--api-cardholders--id--update_location-post)).
            format: date-time
            readOnly: true
            example: 2004-11-18T19:21:52Z
          lastSuccessfulAccessZone:
            type: object
            properties: {}
            description: |
              The last zone the cardholder entered.

              If their last movement was to the 'outside' (through a door that has no access zone
              configured for that direction of travel) this field will be missing but
              `lastSuccessfulAccessTime` will be present.

              If the cardholder is a visitor and their last
              movement was to leave the site, this will be their visit's reception, not an access
              zone.  8.50 and later will present only the name of the reception and withhold the
              href in that case.

              **Change is coming.**

              A future version of Command Centre will add the href field even if the item is a
              reception.  So you can tell the difference, it will add a field called
              `canonicalTypeName` which will have one of two values:  `accesszone` or `reception`.
            readOnly: true
            example:
              href: https://host.com:8904/api/access_zones/333
              name: Twilight zone
          serverDisplayName:
            type: string
            description: |
              If you are running a multi-server installation and this item is homed on a remote server, this
              field will contain the name of that server.  This field is missing from items that are held on
              the machine that served the API request.  Added in 8.40.

              This is a read-only field.  The server will ignore it if you send it.
            readOnly: true
            example: ruatoria.satellite.int
          division:
            type: object
            properties: {}
            description: |
              The division containing this cardholder.  You must send this when creating a
              cardholder.
            example:
              href: https://host.com:8904/api/divisions/2
          '@Student ID':
            type: object
            description: |
              An example Personal Data Field value.

              All PDFs except images appear at the top level of a cardholder in a field
              named after the PDF with a leading '@'.

              Date PDFs will contain a date-time with the time part set to midnight.

              Image PDFs appear as a block named after the PDF with a leading '@'
              containing an href. GETting that href will return the image data with an
              appropriate content-type header.

              Put your PDF values here when creating or modifying a cardholder.  Note that to hold a
              PDF value the cardholder must be a member of an access group that has that PDF
              attached to it.  In this example, being a member of the special projects group has
              granted our Mr. Boothroyd the student ID and photo PDFs.

              To set an image PDF, Base64-encode the image and send it as a string.  There is one in
              the [cardholder POST example](#definition-Cardholder-POST-example).

              Date PDFs are only accurate to a day, so version 8.75 and later will ignore the time
              and time zone components if you send them.  8.70 and earlier will first perform a
              timezone correction then convert it to UTC before truncating the time, which might
              shift the date back a day if you specified a positive timezone offset.  To be sure
              that does not happen on a server older than 8.75, put `T00:00:00Z` on the end of your date.
            example: "8904640"
          disableCipherPad:
            type: boolean
            description: |
              True if this cardholder should not have the numbers on an alarms terminal scrambled
              when the terminal is configured as a cipher pad.  Usually the reason is a vision
              impairment, making a randomised keypad impracticable.
            example: false
          usercode:
            type: string
            description: |
              This field is write-only, so you will not see it in the results of a GET.  It appears
              here because you can send it in the body of a POST or PATCH.

              Set it to the empty string `""` to clear the cardholder's user code.

              If it is not empty it must be a string of at least four digits.  It may need to be
              longer, because the minimum length is set by your site configuration.

              You will find that "0000" does not work.
            example: "numeric, and write-only"
          operatorLoginEnabled:
            type: boolean
            description: |
              True if this operator can log in to the interactive Command Centre clients.  Note that
              a cardholder also needs a privilege to use the Configuration Client.
            example: true
          operatorUsername:
            type: string
            description: |
              The name that the operator uses when logging in to the interactive clients.  Absent if blank.

              Send the empty string `""` to clear it.
            example: qmaster
          operatorPassword:
            type: string
            description: |
              The password this user must supply when logging in to the interactive clients, if they
              are not using Windows integrated authentication.

              Command Centre imposes password length and complexity restrictions.  If your password
              does not meet those requirements, the entire update will fail.  The body of the 4xx
              response will tell you why.

              Like the user code, this is write-only so you will not see it in the results of a GET.
            example: write-only
          operatorPasswordExpired:
            type: boolean
            description: |
              If true, the interactive clients will request a new password the next time this person
              logs in.
            example: false
          windowsLoginEnabled:
            type: boolean
            description: |
              If true, and they have a Windows username, this user can log in using Windows
              integrated authentication.
            example: true
          windowsUsername:
            type: string
            description: |
              This user's Windows username.  For an example of the format that will work in your
              organisation, look in the 'Windows logon' field of the 'Operator configuration' tab of
              a cardholder's properties in the Configuration Client.

              Send the empty string `""` to clear it.
            example: misix.local\qmaster
          oidcLoginEnabled:
            type: boolean
            example: true
            description: |
              If true, and they have an `oidcUserId`, the operator can log in to the Command Centre
              client using their EntraID username.

              Added in 9.40.
          oidcUserId:
            type: string
            example: "admin_qmaster@misix.gov.uk"
            description: |
              This user's EntraID username.  This should be the operator's Entra ID 'User Principal
              Name' found in the overview of the user's details in Entra ID Admin Center.

              Send the empty string `""` to clear it.

              Added in 9.40.

          personalDataDefinitions:
            type: array
            description: |
              All the personal data definitions and values for this cardholder.  It is an array of
              objects, each with one key/value pair.  The key is the name of the PDF preceded by
              an '@'; the value is an object containing the definition of the PDF (common for all
              cardholders) and the value for this cardholder.  The `value` block of an image PDF will
              contain an href to the image.

              Your visibility of a cardholder's PDF value depends entirely on the PDF's access
              settings in your operator groups, or if it has none of those, its default privilege.
              The PDF's division is irrelevant.  So if you were expecting a PDF value here when none
              arrived, ensure the cardholder has a value for that PDF (because the server does not
              send nulls) then check the PDF's access settings in all of your operator groups, then
              the default visibility on the PDF item itself.

              When you send this array in a POST or PATCH, Command Centre will take the
              `notifications` flag from here.  It can take `value` from here too, but if you also
              send a field in the root of the cardholder with the name of the PDF preceded by an
              '@', that one wins.

              To request this block using the 'fields' parameter, use `personalDataFields` (note
              'fields' not 'definitions').  Doing so will not only give you the
              `personalDataDefinitions` block, but also the values at the root level (with their names
              preceded by '@'-signs).
            example:
            - '@Student ID':
                href: https://host.com:8904/api/cardholders/325/personal_data/2356
                definition:
                  href: https://host.com:8904/api/personal_data_fields/2356
                  name: Student ID
                  id: "2356"
                  type: string
                value: "8904640"
            - '@Photo':
                href: https://host.com:8904/api/cardholders/325/personal_data/2369
                definition:
                  href: https://host.com:8904/api/personal_data_fields/2369
                  name: Photo
                  id: "2369"
                  type: image
                value:
                  href: https://host.com:8904/api/cardholders/325/personal_data/2369
            items:
              $ref: '#/components/schemas/CardholderPDF'
          cards:
            type: array
            description: |
              All the cards for this cardholder.  Note that even though Command Centre
              calls these things 'cards', they include other types that do not require a physical
              card, such as digital IDs and mobile credentials.
            items:
              $ref: '#/components/schemas/CardholderCard'
          accessGroups:
            type: array
            description: |
              All the cardholder's access group memberships.  This does not list memberships the
              cardholder inherits through other groups.

              The server property 'Show all cardholder access group memberships' does not affect the
              API as it affects the configuration and operational clients, so this field only
              appears if the operator has permission to see access group memberships.  That is
              granted by a privilege such as 'View cardholders'.
            items:
              $ref: '#/components/schemas/CardholderAccessGroup'
          operatorGroups:
            type: array
            description: |
              All the cardholder's operator group memberships.  Added in 8.50.
            items:
              $ref: '#/components/schemas/CardholderOperatorGroup'
          competencies:
            type: array
            description: |
              Every competency a cardholder possesses.  There is quite a lot there:  see the schema
              definition for detailed explanation.
            items:
              $ref: '#/components/schemas/CardholderCompetency'
          edit:
            type: object
            properties: {}
            description: |
              Reserved for internal use.  It is a link to [another
              call](#operation--api-cardholders--id--edit-get) that helps interactive administrative
              clients.  Do not send it when creating or editing a cardholder.
            readOnly: true
            example:
              href: https://host.com:8904/cardholders/325/edit
          updateLocation:
            type: object
            properties: {}
            description: |
              Link to [POST](#operation--api-cardholders--id--update_location-post) to when you want
              to update the location of this cardholder.  Added in 8.20.
            readOnly: true
            example:
              href: https://host.com:8904/api/cardholders/402/update_location
          notes:
            type: string
            description: |
              Free-form text.

              The 'Edit Cardholder Notes' privilege lets you change cardholder notes however you
              like, but 'Add Cardholder Notes' only lets you add more to the end.  To do that, read
              the existing `notes` field, append your text, and send it back in a PATCH.  If you try
              to change the existing text the server will respond with a 4xx.

              You will need one of those two privileges to edit notes.  'Create Cardholders' and
              'Edit Cardholders' let you set most cardholder fields, but not notes.

              Because of the potential size of the notes field, the server does not return it unless
              you ask for it with `fields=notes`.

            example: ""

          notifications:
            type: object
            properties: {}
            description: |-
              This block shows the cardholder's notification settings.  It deserves some explanation.

              The `enabled` bool is correct at the time of your call.  If false, CC will not be
              sending your cardholder any notifications.

              The `from` and `until` date-times show if and when `enabled` will change.  When the
              `from` date-time passes, `enabled` will flip, the `from` date-time will take the
              `until` value, and `until` will become null.  This continues until `from` is null.

              You can set `from` with a null `until`, but not `until` with a null `from`.  They must
              both be in the future or null, and `from` must be before `until`.

              If you want to simply turn a person's notifications on or off without any changes
              scheduled for the future, set `enabled` true or false and both `from` and `until`
              null.
            example:
              enabled: true
              from: 2017-10-10T14:59:00Z
              until: 2017-10-17T14:59:00Z
          relationships:
            type: array
            description: |
              This is a list of the roles that other cardholders perform for this cardholder.

              Since only one cardholder can perform a given role for another, there will be no more
              elements in this array than there are roles on the site.

              The example shows that this cardholder has one supervisor.
            items:
              $ref: '#/components/schemas/CardholderRelationship'
          lockers:
            type: array
            description: |
              All the cardholder's locker assignments.
            items:
              $ref: '#/components/schemas/CardholderLocker'
          elevatorGroups:
            type: array
            description: |
              The cardholder's elevator group properties. They may have one per elevator group.

              Added in 8.50.
            items:
              $ref: '#/components/schemas/CardholderElevatorGroup'
          updates:
            type: object
            properties: {}
            description: |
              Cardholders include an `updates` block, as other items do, that allows monitoring one
              cardholder per TCP session in a long poll.  However the [Cardholder
              changes](#tag-Cardholder-changes) methods are a far more efficient way of monitoring
              your cardholders.
            example:
              reserved: for future use
          redactions:
            type: array
            description: |
              All the cardholder's scheduled redactions.

              Because this is relatively expensive to compute, this field does not appear by
              default.  You must ask for it with `fields=redactions` or
              `fields=redactions.href,redactions.type,redactions.when`, for example.

              Added in 8.80.
            items:
              $ref: '#/components/schemas/CardholderRedaction'

    CardholderPDF:
      title: Cardholder PDF
      description: |
        A personal data definition and its value for a cardholder.  Each definition is an object
        containing one property named after the PDF (plus a leading '@'), which in turn contains its
        value and notifications flag for the containing cardholder and an object containing some of
        the PDF definition's basic fields.

        This is returned as part of a [cardholder](#definition-Cardholder-detail), and you can send it
        in a [POST](#definition-Cardholder-POST-example) or a
        [PATCH](#definition-Cardholder-PATCH-example) to set the PDF's value and notification flag for
        a cardholder.  The server will ignore the `definition` block if you send it back.  It uses the
        name of the block (minus its leading `@`) to find the PDF to change.

        While you can use this structure to change the value of a cardholder's PDF, it may be simpler
        to put a property in the root of the payload named after the PDF with a leading '@'.
      type: object
      additionalProperties:
        $ref: "#/components/schemas/CardholderPDFContent"

      example:
        '@cellphone':
          href: https://host.com:8904/api/cardholders/325/personal_data/9998
          definition:
            href: https://host.com:8904/api/personal_data_fields/9998
            name: cellphone
            id: "9998"
            type: mobile
          value: a@b.com
          notifications: false

    CardholderPDFContent:
      title: Cardholder PDF content
      description: |
        A personal data definition and its value for a cardholder.  Each definition is an object
        containing the PDF's value (if it is scalar), a link to its value (for image PDFs), and the
        notifications flag for the containing cardholder with an object containing some of the PDF
        definition's basic fields.

      type: object
      properties:
        href:
          type: string
          description: |
            GET this link to receive this cardholder's value for this PDF.  If it is an image you will
            receive the raw image data with an appropriate content-type.  A browser will render it
            correctly.

            This field will be absent if the cardholder does not have a value for the PDF.

            It is read-only:  do not send it in a PATCH or POST.

            If the PDF is not an image the content type will be text/plain, encoded (like
            everything else in this API) as UTF-8.  But you should only use it for image PDFs
            because:

            * Values for scalar PDF types (everything except images) are also given to you in the
              `value` field in this object, described below.

            * The format of date PDFs varies with the Command Centre version.  Old servers return
              it in a format that depends on the server's locale.  This was a bug.  Newer servers
              use ISO 8601.

            * If you learn this URL while a cardholder has the PDF, then the cardholder loses it,
              then you GET the URL, results will vary depending on the server version:  in recent
              versions you will get a 404 for all PDF types, but older servers may return a blank
              string or even a 500.

          format: uri-reference
          readOnly: true
        definition:
          type: object
          properties:
            href:
              type: string
              description: |
                This is the href of the PDF's definition, common to all cardholders who hold a value
                for this PDF.
              format: uri-reference
            name:
              type: string
              description: |
                The PDF's name, without an '@' prefix.
            id:
              type: string
              description: |
                Short alphanumeric identifier used elsewhere in the API to filter cardholder searches
                and add PDF values to alarm and event GETs.
            type:
              type: string
              enum:
              - string
              - image
              - strEnum
              - numeric
              - date
              - address
              - phone
              - email
              - mobile
          description: |
            The definition object is read-only:  do not send it in a PATCH or POST.
          readOnly: true
        value:
          type: string
          description: |
            In a GET response for text, numeric, and date PDFs this will be a scalar containing the
            value, but for image PDFs it will be an object containing a copy of the `href` field
            above.  For date PDFs the string will comply to ISO 8601, but may or may not contain a
            time depending on the version of Command Centre.  Newer versions omit it.  If there,
            it will be midnight UTC.

            In versions up to and including 8.60, if a cardholder did not have an image PDF captured
            (in other words they were a member of an access group that included an image PDF, but they
            did not have a value for it) the API returned the string 'Not captured' in the `value`
            field.  Versions 8.70 and later will not return the `value` field at all if there is no image.

            In a POST or PATCH send text PDFs (including dates) as strings, numeric PDFs as numbers or
            strings that parse to numbers, and image data Base64-encoded into a string.
        notifications:
          type: boolean
          description: |
            In a GET response, this will only appear for email and mobile PDF types.  In a POST or
            PATCH, it only makes sense for the same types.

            If true, cardholder notifications will go to the telephone number or email address held by
            this PDF.  Cardholders can have their notifications go to as many contacts as they wish.

      example:
        '@cellphone':
          href: https://host.com:8904/api/cardholders/325/personal_data/9998
          definition:
            href: https://host.com:8904/api/personal_data_fields/9998
            name: cellphone
            id: "9998"
            type: mobile
          value: a@b.com
          notifications: false

    CardholderCard:
      title: Cardholder card
      type: object
      properties:
        href:
          type: string
          readOnly: true
          description: |
            DELETE this link to delete a card.

            Do not specify it when creating a card.

            DELETE is the only verb you can use on this URL.  GET will always return a 404 in the
            current versions of Command Centre.
          format: uri-reference
          example: https://host.com:8904/api/cardholders/325/cards/97b6a24ard6d4500a9
        number:
          type: string
          description: |
            For a physical access card, this is its card number.  It must be unique across all cards
            of the same card type.  If you leave it blank when creating a card of a type that has a
            decimal number format, Command Centre will use the next available number.

            Card numbers for a mobile credential need not be unique.  They are strings, and are not
            used by Command Centre except for display.

            Card numbers for digital IDs are GUIDs.

            This field is mandatory for card types with text or PIV number formats.  If the card type
            has a text card number format with a regular expression and you supply a card number that
            does not match that regex, Command Centre will reject your update.

            PIV card numbers must be the same as the card's FASC-N.  PIV-I card numbers must not.

            One rule is common across all card types:  you cannot change the number of an existing
            card or credential.
          example: "1"
        cardSerialNumber:
          type: string
          description: |
            The serial number (CSN, MIFARE UID) of a physical access card as a hex string without a
            leading '0x'.  The number is encoded in the traditional way, with an even number of
            numbers and the letters from 'A' through 'F', but the '0x' is missing when it comes out
            of the API and it must be missing when you send it back.

            The example in this example shows a seven-byte serial in the order you can expect in a
            GET and should use in a PATCH or POST.  Those on NXP MIFARE cards start with 04 and end
            with 80 or 90.

            Four-byte serial numbers are in the same format, but shorter: `"EBD62D25"`, for example.

            This may not be not present on older cards.

            This field was read-only until 7.90.  It is read-write in 8.00 and later.
          example: 045A5769713E80
        issueLevel:
          maximum: 15
          minimum: 0
          type: integer
          description: |
            The issue level of a physical access card.  If two cards have the same number
            but different issue levels, only the one with this issue level will gain access.

            If you leave it blank when creating a card, Command Centre will pick an appropriate value.

            If you increase it when modifying a card, all cards with lower issue levels will stop working.

            Do not specify one when creating or updating a mobile credential or digital ID.  They do
            not have issue levels.
          example: 1
        status:
          type: object
          properties:
            value:
              type: string
              description: |
                This card's state, taken from the card type's state set.  The default card
                state set contains 'Active', 'Disabled (manually)', 'Lost', 'Stolen', and
                'Damaged', or translations of those into the server's language.  Your card state sets may
                differ, as they are customisable. PIV cards have extra values covered [in the PIV
                supplement](piv.html#definition-PIV-GET-example).

                In addition to the values in the card type's state set, it will be 'Not Yet Activated'
                if the card's activation date is in the future, 'Expired' if its deactivation date has
                passed, or 'Disabled (by inactivity)' if that is the site's policy.

                Because the values of the `value` field is set by site administrators, you
                should not use it for programmatically determining whether a card is active.
                Use `type` instead.  Use `value` for display.

                When creating or updating a card, set `value` to one of the valid card states from the
                card state set.  Command Centre is not fussy about case.  If you omit it when you
                create a card, Command Centre will use the default for the card state set ('active',
                for the factory state set).
              example: Disabled (manually)
            type:
              type: string
              description: |
                This will be 'pending' if the activation date (`from`) is in the future,
                'expired' if its deactivation date (`until`) is in the past, or 'inactive'
                if it is disabled for one of the reasons given in the card state.

                Never send `type`:  Command Centre always infers it.
              readOnly: true
              example: inactive
              enum:
              - pending
              - active
              - expired
              - inactive
          description: |
            Each card has two status codes:  `value`, and `type`, covered in separate sections below.

            `value` is human-readable.  It comes from the _Card State Set_ configured by the site, and
            could be adjusted according to the card's activation dates.  The REST API and this
            document do not cover card state sets because in most cases, the default set is
            sufficient.  See the online help for the Command Centre client if you wish to create your
            own.

            The second field, `type`, comes from a fixed enumeration, and so is better suited than
            `value` for integrations.  Command Centre derives it from the card's state and activation
            dates.
        type:
          type: object
          properties:
            href:
              type: string
              format: uri-reference
              example: https://host.com:8904/api/card_types/354
            name:
              type: string
              example: Card type no. 1
          description: |
            The name of the card type from the site configuration, and a link to the card type object.

            When creating a card, the href must be a card type that makes sense for the other values
            you placed this object.

            You cannot change a card's type once it is created.
        invitation:
          type: object
          properties:
            email:
              type: string
              description: |
                The email address to which Command Centre will send or did send an invitation for this
                credential.
              example: nick@example.com
            mobile:
              type: string
              description: |
                The telephone number to which Command Centre will send or did send an SMS containing a
                confirmation code for this invitation.
              example: "02123456789"
            singleFactorOnly:
              type: boolean
              description: |
                If you set this true Command Centre will not require a PIN or fingerprint from the
                cardholder when they enrol.  Be aware that without that second authentication factor,
                zones in modes that require a PIN and readers that always require a second factor will
                not grant access to the cardholder.

                `singleFactorOnly` will only be in the result of a GET if it is true.  If it is false,
                the field will be missing.
              default: false
            status:
              type: string
              description: |2

                - `sent` means Command Centre is waiting for the user to accept the invitation, either
                  in Gallagher Mobile Connect or another app that uses the Mobile Connect SDK.

                - `accepted` means that the credential is ready for use.

                - `notSent` means the credential is only a few seconds old or Command Centre is having
                  trouble contacting the cloud.

                - `expired` means that Command Centre did not receive a response in time.
              readOnly: true
              example: sent
              enum:
              - notSent
              - sent
              - expired
              - accepted
            href:
              type: string
              description: |
                Mobile applications use this URL to accept this invitation.  See the Mobile Connect
                SDK documentation for how to do that in your own applications.

                Only present if 'status' is 'sent'.
              format: uri-reference
              readOnly: true
              example: https://security.gallagher.cloud/api/invitations/abcd1234defg5678
          description: |
            Command Centre will only return this object for a mobile credential, and you should send
            it only when creating one.  In the interests of security you cannot modify the invitation
            block of an existing credential.  Someone's thumb might be on its way to accept it, after all.
            If there was something wrong with it you should delete it and start afresh.

            Whether you should send `mobile` or `email` when creating a mobile credential depends on
            whether you are using the Gallagher mobile apps or your own.

            If you specify either `mobile` or `mail` to early-version servers you must also supply the
            other so that Command Centre can send both an email invitation and a confirmation SMS.  It
            is an error to only specify one on those servers.

            Later versions of Command Centre made the SMS verification optional to better support
            installations that use the Gallagher apps but dependence on cellular connectivity is
            undesirable.  You do not need to send a mobile number when creating such a credential.

            If you do not give an email address Command Centre cannot send an invitation to the
            cardholder.  It will be up to another application to complete the creation of this
            credential using the Mobile Connect SDK.

            You should not send a mobile number when creating a credential for use by third-party apps
            that use the Mobile Connect SDK.  SMS is not supported there.

            For more detail on using the Mobile Connect SDK, including more complete coverage of how
            an email address and mobile number are used in the provisioning process, see its
            documentation at [gallaghersecurity.github.io](https://gallaghersecurity.github.io).

        from:
          type: string
          description: |
            The start of the time period during which this card is active.  If this time is in the
            future, the card is not active.

            When it is not set, Command Centre acts as though it is set to a time in the distant past.

            When modifying a card, send a null string `""` to reset it.

            It must be before midnight on the morning of January 1, 2100 _local_ time (so servers with
            positive timezone offsets have maximums during December 31 2099), and it must be less than
            or equal to than the `until` time.  A future version of Command Centre will clamp too-high
            values to December 31 2099 and return a 2xx (success) instead of 400 in that case.

            The server will reject timestamps in card updates that are not in an acceptable format.
            But in requests to create a card, rather than modify an existing card, the server will
            ignore such strings and use the card type's defaults.  This is undesirable behaviour and
            will change in a future version of Command Centre.
          format: date-time
          example: 2017-01-01T00:00:00Z

        until:
          type: string
          description: |
            The end of the time period during which this card is active.  If this time is in the past,
            the card is not active.

            When it is not set, Command Centre acts as though it is set to a time in the distant future.

            When modifying a card, send a null string `""` to reset it.

            It must be before midnight on the morning of January 1, 2100 _local_ time (so servers with
            positive timezone offsets have maximums during December 31 2099), and it must be greater
            than or equal to the `from` time.  A future version of Command Centre will clamp too-high
            values to December 31 2099 and return a 2xx (success) instead of 400 in that case.

            The server will reject timestamps in card updates that are not in an acceptable format.
            But in requests to create a card, rather than modify an existing card, the server will
            ignore such strings and use the card type's defaults.  This is undesirable behaviour and
            will change in a future version of Command Centre.
          format: date-time
          example: 2017-12-31T11:59:59Z

        credentialClass:
          type: string
          description: |
            This indicates the type of the card.  It comes from an enumeration, and is a reliable way
            of determining the credential's type.

            Added in 8.00.

            The experimental `applePass` was added in 9.10.  Its name may change in future versions.

            The `govPass` credential class will change its name in 9.30.
          readOnly: true
          example: mobile
          enum:
          - card
          - digitalId
          - govPass
          - mobile
          - piv
          - pivi
          - trackingTag
          - transact

        trace:
          type: boolean
          description: |
            If set, using this credential will generate an event.

            This field is not in the default set so you will not see it unless you ask for it using
            the `fields` query parameter.

            Added in 8.30.
          example: false

        lastPrintedOrEncodedTime:
          type: string
          description: |
            The date and time this card was last printed or encoded.  It will not come out by
            default - you need to ask for it with `fields=cards.lastPrintedOrEncodedTime`.

            Added in 8.40.
          format: date-time
          readOnly: true
          example: 2020-08-10T09:20:50Z
        lastPrintedOrEncodedIssueLevel:
          maximum: 15
          minimum: 1
          type: integer
          description: |
            The issue level of this card when it was last printed or encoded, provided it was
            non-zero.  It will not come out by default - you need to ask for it with
            `fields=cards.lastPrintedOrEncodedIssueLevel`.

            Added in 8.40.
          readOnly: true
          example: 1
        lastUsedTime:
          description: |
            When a Gallagher controller last observed the credential in use.
          type: string
          format: date-time
          readOnly: true
          example: 2025-09-24T14:00:00Z
        pin:
          type: string
          description: |
            This is a write-only field.
            You can use it in POSTs and PATCHes but the server will not send it to you.

            Being numeric, you might be tempted to send PINs to the server without surrounding quotes.
            However if you do that, leading zeros will be lost when the server converts them to
            integers.  Putting quotes around the PIN forces the server to treat them as strings, 
            preserving leading zeros.

            8.90 servers will reject your request if the card's `credentialClass` is not `card`,
            `piv`, `piv-i`, or `govPass`.  More recent servers will issue a warning in that case, and
            will not set the PIN, but will allow the rest of the update.

            PINs were added to the API in 8.90.
          example: "153624"
        visitorContractor:
          type: boolean
          description: |
            This is a credential property only for GovPass, indicating that the enrolled credential is
            for a visitor / contractor.

            It is a write-once field new to 9.00.
          example: false
        ownedBySite:
          type: boolean
          description: |
            This is a credential property only for GovPass, indicating if the site is the owner of the
            card.

            It is a read-only field new to 9.00.
          readOnly: true
          example: false
        credentialId:
          type: object
          description: Reserved for use by Gallagher applications.
          example: reserved
        bleFacilityId:
          type: object
          description: Reserved for use by Gallagher applications.
          example: reserved

        encodingData:
          type: object
          readOnly: true
          properties:
            mifareClassic:
              type: object
              properties:
                href: { type: string, format: uri-reference }
            mifareDesfire:
              type: object
              properties:
                href: { type: string, format: uri-reference }
          description: |
            This block contains links to the calls that return the data you will need to encode
            MIFARE DESFire and Classic cards.

            Read-only:  the server will ignore it if you send it.

            Added in 9.50.

            Not returned by default:  ask for it by adding `cards.encodingData` to your `fields`
            query parameter.
          

      description: |
        A _card_ is an access credential, including physical cards and mobile (Bluetooth and NFC)
        credentials and digital IDs.  The server returns it as part of a [cardholder's
        details](#definition-Cardholder-detail), and you supply it when creating or modifying a card
        or credential on a cardholder.

        Every card has a type, a status, and a validity period.  Its type determines other fields of
        relevance, described below.

        PIV cards are complex enough to warrant a [document of their own](piv.html).

    CardholderAccessGroup:
      title: Cardholder access group
      type: object
      properties:
        href:
          type: string
          description: |
            DELETE this URL to remove this group membership, and use it in the body of a PATCH to a
            cardholder to identify memberships you want to modify.

            Note that changing an access group membership with a PATCH will change this href.  Do not
            cache it.

            DELETE is the only verb you can use on this URL.  GET returns a 404.
          format: uri-reference
          example: https://host.com:8904/api/cardholders/325/access_groups/D714D8A89F
        accessGroup:
          type: object
          description: |
            An object containing a link to this group's detail page and (when sent by the the server)
            its name.  You should not send it when modifying a group membership because you cannot
            change a group membership's group; you can only change its dates.  But you must send it
            when adding a new group membership, of course, because it identifies the cardholder's new
            group.  Just send the href:  don't bother with the name.

            8.70 and later will not return the link if your operator does not have the privilege to
            view the access group (given by 'View access groups', for example).
          example: { name: "R&D special projects group", href: "https://host.com:8904/api/access_groups/352" }
        status:
          type: object
          properties:
            value:
              type: string
              description: |
                The state of this cardholder's access group membership, in the site's language.  In an
                English locale, the value is the same as the type, but capitalised.
              readOnly: true
              example: Pending
            type:
              type: string
              description: |
                The state of this cardholder's access group membership.

                This will be 'pending' if the activation date is set and in the future,
                'expired' if its deactivation date is set and in the past, or 'active'.
              readOnly: true
              example: pending
              enum:
              - pending
              - active
              - expired
          description: |
            The two fields in this block are read-only because they are determined by the `from` and
            `until` dates.
          readOnly: true
        from:
          type: string
          description: |
            The start of the time period during which this group membership is active.  If
            this time is in the future, the card will be inactive.

            When sending this to a server of version 7.90.883 or earlier, use UTC with a trailing 'Z'.
            More recent versions understand timezone offsets.
          format: date-time
          example: 2017-01-01T00:00:00Z
        until:
          type: string
          description: |
            The end of the time period during which this group membership is active.  If
            this time is in the past, the card will be inactive.

            When sending this to a server of version 7.90.883 or earlier, use UTC with a trailing 'Z'.
            More recent versions understand timezone offsets.
          format: date-time
          example: 2017-12-31T11:59:59Z
      description: |
        An _access group_ is an object in Command Centre.  This section is about a connection between an access group and
        a cardholder, called a _membership_.  A cardholder can be a member of many groups, and groups
        can have any number of members.

        Less obvious is that a cardholder can have many memberships to the same group.  This is useful
        because a membership has a validity period, expressed with `from` and `until` date-times.
        Outside those moments Command Centre does not regard the cardholder as being a member of the
        group.  If there exists one membership with `from` in the past or unset and `until` in the
        future or unset, the cardholder is a member.

        Presence in an access group affects physical access rights and possession of PDFs, among other
        things.

        The membership object can come from the server in a cardholder's details, and you send it to
        the server when modifying a cardholder's group memberships.  All uses are described below.

    CardholderOperatorGroup:
      title: Cardholder operator group
      type: object
      properties:
        href:
          type: string
          description: |
            DELETE this URL or use it in the 'operatorGroups' block of a [cardholder
            PATCH](#operation--api-cardholders--id--patch) to remove this operator group membership.

            DELETE is the only verb you can use on this URL.  GET will always return a 404.
          format: uri-reference
          example: https://host.com:8904/api/cardholders/325/operator_groups/EBDRSD
        operatorGroup:
          type: object
          description: |
            An object containing a link to this operator group's detail page and its name.  It is
            marked read-only because you do not send it to the server when managing a cardholder's
            operator groups:  you cannot change a group membership's group.

            The link will be absent if your operator does not have the privilege to view the operator
            group ('View operators' or 'Edit operators', for example).
          readOnly: true
          example: { name: "Locker admins", href: "https://host.com:8904/api/operator_groups/532" }
      description: |
        An _operator group_ is an object in Command Centre.  The connection between an operator group
        and a cardholder is a _membership_.  A cardholder can be a member of many different operator
        groups, and operator groups usually have more than one member, but a cardholder can only have
        one membership to a given operator group at a time.  This is because an operator group
        membership, unlike an access group membership, does not have start and end dates.

        Presence in an operator group affects software access.  Your REST operator, for example, must
        be in an operator group that grants privileges otherwise it will receive nothing but 404s.

        Added to the API in 8.50.

    CardholderCompetency:
      title: Cardholder competency
      type: object
      properties:
        href:
          type: string
          description: |
            Use this URL as the target of a DELETE to remove a cardholder's competency, or in the body
            of a cardholder PATCH to modify it.

            DELETE is the only verb you can use on this URL.  GET will always return a 404.
          format: uri-reference
          readOnly: true
          example: https://host.com:8904/api/cardholders/325/competencies/2dc3p0
        competency:
          type: object
          properties:
            href:
              type: string
              format: uri-reference
          description: |
            This contains the competency's name and its href.  They are read only because they
            belong to the competency itself, not the cardholder's link to it.
          readOnly: true
          example:
            href: https://host.com:8904/api/competencies/2354
            name: Hazardous goods handling
        status:
          type: object
          properties: {}
          description: |
            This object contains two strings.  Both are read-only, so do not specify them when
            assigning or updating a cardholder's competency.  `value` is taken from the site's
            language pack, suitable for display. `type` comes from a fixed enumeration.  It will be
            `expiryDue` or `active` when the cardholder carries this competency; anything else means
            no.  A fuller explanation follows.

            A competency can be disabled, expired, both, or neither.  Whether it is _enabled_ is a
            flag on the cardholder's holding of the competency.  Whether it is _expired_ is derived from an expiry
            timestamp (accurate to the second):  if it is in the past, Command Centre considers the
            competency expired.

            A competency can also have an `enablement` date.  If that date (timestamp) passes while the
            competency is disabled, Command Centre will enable the competency.  It will leave the date on
            the item for future reference, though it will not affect the competency again.

            If the competency is disabled, the status `type` will be `inactive` when there is no
            enable date or it is in the past, and `pending` when the enable date is in the future
            (i.e., there is an automatic re-enablement coming).

            If the competency is not disabled, the `expiry` time is important.  If it is in the past,
            `type` will be `expired`.

            All of those cases are negative.  Two remain, when our cardholder is blessed with an
            enabled and active competency.  `type` will be `expiryDue` if the `expires` time is in the
            future but within the competency's advance notice period, or `active` if the `expires`
            time is beyond the advance notice period or not set at all.

            You can see and set the enabled flag, the enable date, and the expiry date via this
            API.

            When creating a cardholder or updating a competency on an existing cardholder, you should
            set the `enabled` field one way or the other, and the `enablement` and `expiry` dates if
            you wish.  They will determine the contents of this status block.

            Here it is in table form.  The first two rows are the positive cases, when Command Centre
            would grant access to a competency-enforced zone.

            | Enabled flag | Enablement date | Expiry date | `status.type`
            | ------------ | -------------- | --------| ----- |
            | true | - | Far future | active |
            | true | - | Near future | expiryDue |
            | true | - | Past | expired |
            | false | Future | - | pending |
            | false | Past | - | inactive |
            | false | Unset | - | inactive |
          readOnly: true
          example:
            value: Pending
            type: pending

        expiryWarning:
          type: string
          description: |
            The time at which the cardholder will (or did) receive a warning about the
            competency expiring.  If this time is set and in the past but the competency has
            not yet expired and is still enabled, the status type will be `expiryDue`.
          format: date-time
          readOnly: true
          example: 2017-03-06T15:45:00Z
        expiry:
          type: string
          description: "The time at which the competency will expire.  If this time\
            \ is set, in the past, and the competency is enabled, status type will\
            \ be `expired`."
          format: date-time
          example: 2017-03-09T15:45:00Z
        enablement:
          type: string
          description: "The time at which the competency will be re-enabled.  If set\
            \ and in the future, and the competency is disabled, the status type will\
            \ be `pending`."
          format: date-time
          example: 2018-03-09T15:45:00Z
        comment:
          type: string
          description: The comment appears in the management clients when viewing
            the cardholder.
          example: CPR refresher due March.
        limitedCredit:
          type: boolean
          description: |
            If false, Command Centre's 'Pre-pay Car Parking' feature (available under its own licence)
            will not reduce the current credit.

            This field will be in the results if its value is true.
          example: true
        credit:
          type: integer
          description: |
            The balance, or amount of credit left on this competency for use by Pre-pay Car Parking.
            It can be negative.

            This field will be in the results if its value is not zero.
          example: 37
      description: |
        A _competency_ is an object in Command Centre with some basic fields like a name and a notice
        period.  Its purpose is to allow a site to refuse access to cardholders who do not meet a
        special requirement.

        This section describes the link between a cardholder and a competency.  The status of that link
        determines whether they "hold" the competency for the purposes of access control decisions at
        the door.  When we talk about updating, adding, or deleting a competency in the cardholder
        API, we do not mean the competency object itself, but rather the link a cardholder has to the
        competency.

        The link is a block in the cardholder detail.  You can also put it in the results of a
        cardholder search by putting `competencies` in the `fields` parameter.

        This particular section describes what you receive from a GET.  The [Cardholder competency
        update](#definition-Cardholder-competency-update) describes what you should send in a POST or
        PATCH to set or update a cardholder's link to a competency.

    CardholderRelationship:
      title: Cardholder relationship
      description:  |
        A _role_ is an object in Command Centre.  They are usually named using nouns such as
        'supervisor', 'manager', or 'team leader'.

        The operator clients and the REST API allow you to create a link between two
        cardholders, called a relationship, using a role.  The link is directional:  we
        refer to the cardholder who 'has' the role as the child, and the cardholder who
        performs or 'is' the role as the parent.

        A parent can perform a role for any number of child cardholders, but a child can only have one
        relationship (parent) for each role.  Command Centre will reject your submission if you try to
        create a relationship when one already exists for the same child and role.

        For example, a role on your system might be 'supervisor'.  A cardholder can be a supervisor
        for any number of others, but will only have one supervisor.

        Loops are possible:  two cardholders can supervise each other, for example.

        The REST API manages relationships through the child cardholder.  You can create them at the
        same time as creating the child in a POST, or add them later in a PATCH.

        There is currently no way to list all a cardholder's children in one request (everyone a
        particular cardholder is supervising, for example).  You would achieve that by iterating
        through all cardholders, after re-reading the efficiency tips, and checking their
        relationships - quite easily done in JSONPath.

        This section describes the object you receive in a cardholder's detail page and you will send
        in a POST or PATCH.  The child cardholder does not appear in it because he or she is
        identified by the URL of the request.

      properties:
        href:
          type: string
          format: uri-reference
          description: |
            DELETE this link, or put it in `relationships.remove.href` of a PATCH, to sever the
            relationship between the two cardholders.  Specify it in `relationships.update.href` of a
            PATCH to update the relationship.

            Do not specify it when creating a new relationship.

            DELETE is the only verb you can use on this URL.  GET will always return a 404.

          example: "https://host.com:8904/api/cardholders/325/relationships/179lah1170"
        role:
          type: object
          description: |
            This is the role that the parent identified in the next block performs for the cardholder
            identified by the request URL.

            Once set, this cannot be changed.  Command Centre will ignore it if you send it
            in an update PATCH.  If you need to swap a parent from one role to another, send
            an add and a delete in the same PATCH.
          example:
            href: "https://host.com:8904/api/roles/5396"
            name: "Supervisor"
        cardholder:
          type: object
          description: |
            The href and name of the cardholder that performs this role.

            The three name fields are read-only:  Command Centre sends them to you in the body of a
            GET but will ignore them if you send them in the body of a POST or PATCH.

            This block and the href in it are unnecessary when deleting a relationship.  The href is
            required when creating one, and optional when updating, but strongly advised since the
            cardholder is the only thing about a relationship you can change.

            `firstName` and `lastName` appeared in 8.20.

          example:
            href: "https://host.com:8904/api/cardholders/5398"
            name: "Miles Messervy"
            firstName: "Miles"
            lastName: "Messervy"

    CardholderLocker:
      title: Cardholder locker
      description: |
        These appear in an array in a cardholder detail, showing the cardholder's allocated lockers.
        Each allocation has `from` and `until` dates, much like cards and access group memberships,
        outside of which the allocation is inactive.

        A locker can have allocations to more than one cardholder, with separate or overlapping
        periods.  Unlike access groups, however, one cardholder cannot have more than one allocation
        to the same locker.

      properties:
        href:
          type: string
          format: uri-reference
          description: |
            DELETE this to end a cardholder's use of a locker, or use it to identify the
            allocation you wish to modify in a [cardholder
            PATCH](#operation--api-cardholders--id--patch).

            DELETE is the only verb you can use on this URL.  GET will always return a 404.

          example: "https://host.com:8904/api/cardholders/325/lockers/t1m4"
        locker:
          description: |
            This href in this object is a link to the allocated locker, and is the identifier to use
            when allocating the same locker to another cardholder.

            The object also contains the name and short name of the locker, and the name and
            identifying href of its bank.

          type: object
          example:
            name: "Bank A locker 1"
            shortName: "A1"
            lockerBank:
              href:  "https://host.com:8904/api/locker_banks/4567"
              name: "Bank A"
            href:  "https://host.com:8904/api/lockers/3456"
        from:
          description: |
            The start of the time period during which the cardholder has access to this locker.

            Send an empty string `""` to reset it.
          type: string
          format: date-time
          example: "2017-01-01T00:00:00Z"
        until:
          description: |
            The end of the time period during which the cardholder has access to this locker.

            Send an empty string `""` to reset it, making the allocation permanent.
          type: string
          format: date-time
          example: "2018-12-31T00:00:00Z"

    CardholderElevatorGroup:
      title: Cardholder elevator group
      description: |
        These appear in an array in a cardholder detail, showing the cardholder's elevator
        group properties.

        A cardholder can have one default floor per elevator group. The elevator system will
        prepare a car to carry that cardholder to the access zone shown here when the cardholder
        badges a card at an appropriately configured kiosk.

        Elevator system features can be activated by enabling the feature for an elevator group.
        For example, 'VIP features' gives exclusive access to an elevator car to the passenger.

      properties:
        href:
          type: string
          format: uri-reference
          description: |
            The href of this cardholder's elevator group entry.  DELETE this to remove it from the
            cardholder.
          example: "https://host.com:8904/api/cardholders/325/elevator_groups/567"
        elevatorGroup:
          description: |
            The href and name of the elevator group for which this cardholder has a default
            floor or passenger types.
          example: {
            href: "https://host.com:8904/api/elevator_groups/635",
            name: "Main building lower floors" }
        accessZone:
          description: |
            The href and name of the access zone (floor) to which this cardholder is most
            likely to want to travel after entering the group's main elevator lobby. This 
            property will be missing if the cardholder does not have a default floor for this elevator group.
          example: {
            href: "https://host.com:8904/api/access_zones/637",
            name: "Lvl 1 lift lobby"}
        enableCaptureFeatures:
          type: boolean
          description: |
            Cardholders can select and recall specific elevators to specific floors using
            a kiosk. Once captured, the elevator car can be placed on independent service to
            give users control of the car to clean the interior or perform maintenance.
          example: true
        enableCodeBlueFeatures:
          type: boolean
          description: |
            A special elevator mode which is commonly found in hospitals. It allows an elevator
            to be summoned to any floor for use in an emergency situation.
          example: false
        enableExpressFeatures:
          type: boolean
          description: |
            Allows the cardholder to program selected elevators to cycle continuously between two
            floors for a pre-determined duration. For example, this feature can help hotels transport
            food efficiently from their kitchen to a ballroom on another floor. You can also prevent
            other guests from boarding to provide your banquet guests with VIP treatment.
          example: true
        enableServiceFeatures:
          type: boolean
          description: |
            Service personnel can use this function to call an empty elevator and ride it nonstop
            to their destination floor. The user simply registers a call via a card swipe or PIN entry
            that is pre-programmed to grant access.
          example: false
        enableService2Features:
          type: boolean
          description: |
            Service personnel can use this function to call an empty elevator and ride it nonstop
            to their destination floor. The user simply registers a call via a card swipe or PIN entry
            that is pre-programmed to grant access.
          example: true
        enableService3Features:
          type: boolean
          description: |
            Service personnel can use this function to call an empty elevator and ride it nonstop to
            their destination floor. The user simply registers a call via a card swipe or PIN entry
            that is pre-programmed to grant access.
          example: true
        enableVipFeatures:
          type: boolean
          description: |
            VIP operation allows cardholders to swipe a card or enter a PIN to isolate the elevator
            and provide uninterrupted access to their designated floor.
          example: false

    CardholderPOST:
      title: Cardholder post
      description: |
        This is an example of a POST you could use to create a cardholder in a specific division and
        access group, with an access card, another cardholder as a supervisor, a competency, a student
        ID and a photo held in personal data fields, and two lockers.

        There are plenty more fields than shown in this example.  For a complete list please see the
        schema for the detailed [cardholder object](#definition-Cardholder-detail) that you receive
        from a cardholder href.

      required: [ division ]
      properties:
        firstName:
          type: string
          description: You must supply either this or the last name when creating a cardholder.
          example: "Algernon"
        lastName:
          type: string
          description: You must supply either this or the first name when creating a cardholder.
          example: "Boothroyd"
        shortName:
          type: string
          example: "Q"
        description:
          type: string
          example: "Quartermaster"
        authorised:
          description: |
            Remember to set this true, as shown here in the POST, or later in a PATCH.  Otherwise your
            new cardholder will never get through a door.
          type: boolean
          example: true
        division:
          type: object
          description:  |
            Mandatory when creating any cardholder.  In this example, we want all students
            in division 5387.
          example:
            href: "https://host.com:8904/api/divisions/5387"
        "@email":
          description: |
            An example PDF value.  In this example, access group 352 must include a PDF
            called 'email' otherwise this will appear to have no effect.

          type: string
          example: "user@sample.com"
        "@headshot":
          description: |
            An example image PDF encoded to Base64.  Access group 352 must include this PDF as well.
            As a quick visual check on your encoding, JPEGs start with `/9j/`.
          type: string
          example: "/9j/4A...=="
        personalDataDefinitions:
          description: |
            This is how you set and unset the notifications flags on PDFs.  If you do not do it here
            when you first give a cardholder a PDF, it will come from the PDF's definition.
          type: array
          items: {$ref: '#/components/schemas/CardholderPDF'}
          example:
            - "@email": {notifications: true}
        cards:
          description: |
            This example creates one physical card of type 600 with a PIN and a system-generated card
            number, and
            another of type 654 which--judging by the invitation block--must be a mobile credential.
            Command Centre will send an invitation to Nick at those coordinates.

            Card PINs were added to the API in 8.90.
          type: array
          items: {$ref: '#/components/schemas/CardholderCard'}
          example:
            - type: {href: "https://host.com:8904/api/card_types/600"}
              pin: "153624"
            - type: {href: "https://host.com:8904/api/card_types/654"}
              number: "Nick's mobile"
              invitation:
                email: "nick@example.com"
                mobile: "02123456789"

        accessGroups:
          type: array
          items: {$ref: '#/components/schemas/CardholderAccessGroup'}
          description:  |
            Here you can add the access groups necessary to give your new cardholder the
            PDFs and access he or she needs.  In this example we set the activation date of
            the access group membership to the first of January 2019.
          example:
            - accessgroup:
                href: "https://host.com:8904/api/access_groups/352"
              from: "2019-01-01T00:00:00Z"
        operatorGroups:
          type: array
          items: {$ref: '#/components/schemas/CardholderOperatorGroup'}
          description:  |
            Here you can add the operator groups necessary to give your new cardholder the
            software access he or she needs.  Added in 8.50.
          example:
            - operatorgroup:
                href: "https://host.com:8904/api/operator_groups/523"
        competencies:
          type: array
          items: {$ref: '#/components/schemas/CardholderCompetency'}
          description: |
            In this example we are giving our new cardholder a disabled competency, set to enable in
            January 2019.
          example:
            - competency:
                href: "https://host.com:8904/api/competencies/2354"
              enabled: false
              enablement: "2019-01-01T00:00:00Z"

        notes:
          type: string
          example: ""
        notifications:
          type: object
          description: "You can set or update any of the three fields in this block."
          example:
            enabled: true
            from: "2017-10-10T14:59:00Z"
            until: "2017-10-17T14:59:00Z"
        relationships:
          type: array
          items: {$ref: '#/components/schemas/CardholderRelationship'}
          description: |
            Here you would set the cardholders who will perform roles for this cardholder.

            The example shows that this cardholder will have cardholder 5398 performing role 5396.

            Remember that you can supply an array of these objects if your cardholder is having more
            than one role filled.
          example:
            - role:
                href: "https://host.com:8904/api/roles/5396"
              cardholder:
                href: "https://host.com:8904/api/cardholders/5398"
        lockers:
          type: array
          description: |
            Here you set all the cardholder's locker assignments.  Ensure you are only attempting to
            give your cardholder a locker according to site policy (one locker per locker bank, for
            example), otherwise the POST will fail.

            The example shows our cardholder receiving two lockers.
          items: {$ref: '#/components/schemas/CardholderLocker'}
          example:
            - locker:
                href:  "https://host.com:8904/api/lockers/3456"
            - locker:
                href:  "https://host.com:8904/api/lockers/3457"

        elevatorGroups:
          type: array
          description: |
            Here you set all the new cardholder's default elevator floors and passenger types. Passenger type properties
            are false by default.

            The example shows our cardholder receiving a default floor for the first elevator group,
            with the Code Blue feature enabled in the second group.

            Added in 8.50.
          items: {$ref: '#/components/schemas/CardholderElevatorGroup'}
          example:
            - elevatorGroup:
                href:  "https://host.com:8904/api/elevator_groups/635"
              accessZone:
                href:  "https://host.com:8904/api/access_zones/637"
            - elevatorGroup:
                href:  "https://host.com:8904/api/elevator_groups/639"
              enableCodeBlueFeatures: true

    CardholderUpdateLocationPOSTExample:
      title: Cardholder update location POST example
      description: |
       
        This is an example of a POST you could use to move a cardholder to a target access zone.

      properties:
        accessZone:
          type: object
          properties:
            href:
              type: string
              format: uri-reference
              example: "https://host.com:8904/api/access_zones/412"
              description: |
                The href of the access zone into which you want to move your cardholder.  This example
                came from the [access zones
                controller](rest.html#operation--api-access_zones-update_cardholder_location-get), but
                you can also use an href from the [items controller](events.html#tag-Items) if you do
                not have a RESTStatus or (in 8.60) RESTOverrides licence.

    CardholderPATCHExample:
      title: Cardholder PATCH example

      description: |

        ***TODO*** reword as the schema rather than an example

        Send one of these in a PATCH to `/api/cardholders/{id}` to modify the cardholder at that URL,
        or to add and modify cards, competencies, groups, and relationships.

        All the cardholder fields you can supply are described in the [cardholder
        detail](#definition-Cardholder-detail).

        This example:

          - sets 'authorised' true,
          - sets a PDF holding an employee ID,
          - changes the notification flags on two PDFs,
          - adds two new credentials, one card and one mobile,
          - changes the issue level with `Stolen` as the reissue reason and clears the until date on another credential,
          - deletes a third credential with `Lost` as the remove reason,
          - adds two access group memberships, one unending and one with an until date,
          - clears the until date on another access group membership,
          - removes a fourth access group membership,
          - adds a competency, inactive, with a future enablement date,
          - activates a competency that the cardholder already had,
          - adds one relationship,
          - changes the cardholder on another,
          - adds one locker assignment with a from date,
          - sets the until date on another locker assignment,
          - removes a third locker assignment,
          - adds two operator group memberships,
          - removes a third operator group membership,
          - adds an elevator group with a default floor,
          - modifies another elevator group, turning the 'code blue' feature on and the VIP feature off, and
          - removes a third elevator group.

        This is also the method you use for changing a cardholder's name, description, notes, user
        code, etc.

        In addition to those fields, this PATCH format accepts five arrays:  'cards',
        'accessGroups', 'competencies', 'relationships', and (in 8.50) 'operatorGroups'.

      properties:
        authorised:
          type: boolean
          example: true
          description: |
            You can modify [all the fields](#definition-Cardholder-detail) on a cardholder, provided
            you have the necessary privileges.
        firstName:
          type: string
          example: Erica
        "@employeeId":
          type: string
          example: THX1139
          description: |
            Replace PDF values as though they were flat fields on a cardholder.  Prefix the name of
            the PDF with `@`, and Base64-encode images.  Send 'null' if you want to delete a PDF value.

            Remember that a cardholder's record will not return a PDF if he or she is not a member of
            the access group that grants that PDF.  In this example, one or both of access groups 352
            and 124 are attached to 'employeeId'.
        personalDataDefinitions:
          description: |
            This is how you set and unset the notifications flags on PDFs.  Presumably this cardholder
            wants to receive notifications at the email address stored in the 'email' PDF rather than
            by SMS.
          type: array
          items: {$ref: '#/components/schemas/CardholderPDF'}
          example:
            - "@email": {notifications: true}
            - "@cellphone": {notifications: false}

        cards:
          type: object
          description: |
            This object can contain three arrays, named 'add', 'update', and 'remove'.  Every element
            you put in those arrays should be in the [card schema](#definition-Cardholder-card).

            Each element of the 'add' array will need a 'type' member, at the very least.  Every card
            field makes sense here except 'href'.  Only existing cards have hrefs.  This example adds
            two cards:  one has nothing more than the type, so it will receive blank 'from' and
            'until' dates and a computed number and issue level.  The other is a mobile credential (it
            has an 'invitation' block) with a custom initial state.

            Each element of the 'update' array should be a card to modify.  It will need the href of
            that card, plus the fields you want to change.  Remember you cannot change a card's type.
            The example changes the issue level and resets the 'until' date.

            The only field that makes sense in an element of the 'remove' array is 'href' and 'status'.

            You can remove and add cards in the same PATCH.  In fact you should do that in preference
            to making multiple API calls.  That is a good way of reissuing a mobile credentials, for
            example:  put the href to the old one in the 'remove' array and a new invitation in the
            'add' array.  The new credential should have the same card number and the same 'type' and
            'invitation' blocks as the credential you're re-issuing.

            Do not put the same href in both the 'update' and 'remove' arrays.

            In version 8.90 and later you can specify a card state in the `value` field inside the
            `status` block when removing a card or changing its issue level.  It becomes the final
            state of the card if you remove it or the final state of the card with the previous issue
            level if you re-issue it, so it must be one of the valid states for the card type.  The
            Gallagher clients and the resulting event call this state the 'reason' for the re-issue or
            removal.  By default it will be the same as the card's current state.

          example:
            add:
              - type:
                  href: "https://host.com:8904/api/card_types/354"
                pin: "153624"
              - type:
                  href: "https://host.com:8904/api/card_types/600"
                number: "Jock's iPhone 8"
                status: { value: "Pending sign-off"}
                invitation: { email: "jock@example.com" }
            update:
              - href: "https://host.com:8904/api/cardholders/325/cards/97b6a24ard6d4500a9d"
                issueLevel: 2
                until: ""
                status: { value: "Stolen" }
                pin: "153624"
            remove:
              - href: "https://host.com:8904/api/cardholders/325/cards/77e8affe7c7e4b56"
                status: { value: "Lost" }

        accessGroups:
          type: object
          description: |
            Like the 'cards' object, this can contain three arrays named 'add', 'update', and
            'remove'.  Every element you send in those arrays should be in the [access group
            schema](#definition-Cardholder-access-group).

            This operation does not modify access groups in Command Centre; it works on a cardholder's
            memberships to those groups.

            Each element of the 'add' array will need an 'accessGroup' member containing an href
            identifying the group to which you wish to add the cardholder.  The other fields are
            optional.  If you omit 'from', the membership will take effect immediately.  If you omit
            'until', it will be unending.

            Each element of the 'update' array will need an href identifying the membership (not the group!) to update,
            and one or both of the 'from' and 'until' date-times with new values.  You cannot
            change the group:  just the activity period.  The example removes the until date, effectively making
            the group membership unending.

            In version 7.90.883 or earlier, 'from' and 'until' should be in UTC with a
            trailing 'Z'.  Releases after 883 understand different timezones here.

            Note that updating a cardholder's group membership will change its href, so do not cache
            it.

            The only field that makes sense in an element of the 'remove' array is the href.

            Do not put the same href in both the 'update' and 'remove' arrays.

          example:
            add:
              - accessGroup:
                  href: "https://host.com:8904/api/access_groups/352"
              - accessGroup:
                  href: "https://host.com:8904/api/access_groups/124"
                until: "2019-12-31"
            update:
              - href: "https://host.com:8904/api/cardholders/325/access_groups/10ad21"
                until: ""
            remove:
              - href: "https://host.com:8904/api/cardholders/325/access_groups/10ed27"

        competencies:
          type: object
          description: |
            Like the cards and accessGroups objects, this can contain three arrays named 'add',
            'update', and 'remove'.  Every element should be in the [cardholder competency
            schema](#definition-Cardholder-competency).

            This operation does not modify Command Centre's competencies:  it works on a cardholder's
            holdings of those competencies.

            Each element of the 'add' array will need a 'competency' block containing an href member
            identifying the competency you wish to grant the cardholder.  All other fields are optional.
            Note that attempting to give a cardholder a competency he or she already has
            will result in an error or an alarm depending on the server version.

            Each element of the 'update' array will need an href identifying the
            cardholder/competency link to update, and one or more of the 'expiry', 'enabled',
            'enablement', 'comment', 'limitedCredit', and 'credit' fields.

            The only field that makes sense in an element of the 'remove' array is the href
            of the link between the cardholder and the competency.

            Do not put the same href in both the 'update' and 'remove' arrays.

            In this example we are giving the cardholder a disabled competency which will enable
            in 2021, and activating another competency.

          example:
            add:
              - competency:
                  href: "https://host.com:8904/api/competencies/2354"
                enabled: false
                enablement: "2021-01-01T08:00+13"
            update:
              - href: "https://host.com:8904/api/cardholders/325/competencies/2dc3"
                enabled: true

        relationships:
          type: object
          description: |
            It should be no surprise that this can contain three arrays named 'add', 'update', and
            'remove', and that every element should be in the [relationship
            schema](#definition-Cardholder-relationship).

            This operation does not modify Command Centre's roles:  it works on the relationships
            between two cardholders.

            Each element of the 'add' array will need a 'role' member containing an href identifying
            the type of relationship you wish to establish, and a 'cardholder' member containing an
            href identifying the other party (the one who will perform the role for the cardholder at
            the URL you are PATCHing).  There are no optional fields.

            Each element of the 'update' array will need an href identifying the relationship to
            update, and one or both of the 'role' and 'cardholder' blocks containing the updated
            values.  The example leaves the role but changes the cardholder - a new supervisor,
            presumably.

            The only field that makes sense in an element of the 'remove' array is the href.

            Do not put the same href in both the 'update' and 'remove' arrays.

          example:
            add:
              - role:
                  href: "https://host.com:8904/api/roles/5396"
                cardholder:
                  href: "https://host.com:8904/api/cardholders/5398"
            update:
              - href: "https://host.com:8904/api/cardholders/325/roles/1799lah1170"
                cardholder:
                  href: "https://host.com:8904/api/cardholders/10135"

        lockers:
          type: object
          description: |
            With you well in the habit by now, each element of your three arrays should be in the
            [cardholder locker schema](#definition-Cardholder-locker).  They will allocate lockers to
            cardholders, de-allocate them, and adjust validity periods.

            Each member of the 'add' array will need a 'locker' member containing an href identifying
            the locker to allocate.  The cardholder you will allocate it to is identified by the
            request URL, remember.

            Each member of the 'update' array will need an href identifying the allocation to update,
            and one or both of the 'from' and 'until' date-times.

            The validity period is all you can change about a locker allocation.  If you want to
            change the locker, delete the old one and add a new.  You can do that in the same PATCH,
            with one element in each of the 'add' and 'remove' arrays.

            This example allocates one locker starting in January 2019, sets the end-date of an
            existing allocation to the end of February 2020, and removes another entirely.

          example:
            add:
              - locker:
                  href: "https://host.com:8904/api/lockers/1200"
                  from: "2019-01-01"
            update:
              - href: "https://host.com:8904/api/cardholders/325/lockers/wxyz1234"
                until: "2020-02-29"
            remove:
              - href: "https://host.com:8904/api/cardholders/325/lockers/abcd4321"

        operatorGroups:
          type: object
          description: |
            This can contain two arrays named 'add' and 'remove'.  Every element you send in those
            arrays should be in the [cardholder operator group
            schema](#definition-Cardholder-operator-group).

            Each element of the 'add' array will need an 'operatorGroup' member containing an href
            identifying the operator group to which you wish to add the cardholder.  Supported in 8.50
            and later.

            The only field that makes sense in an element of the 'remove' array is the href.  Make
            sure it is the href of the membership, not of the operator group.  Supported in 8.90 and
            later.

            There is nothing about an operator group membership that you can change so there is no
            point to an 'update' array.  Operator group memberships are, or are not:  there is no
            update.

          example:
            add:
              - operatorGroup:
                  href: "https://host.com:8904/api/operator_groups/532"
              - operatorGroup:
                  href: "https://host.com:8904/api/operator_groups/535"
            remove:
              - href: "https://host.com:8904/api/cardholders/325/operator_groups/EBDRSD"

        elevatorGroups:
          type: object
          description: |
            This can contain three arrays named 'add', 'update', and
            'remove', each containing an element in the [cardholder elevator group
            schema](#definition-Cardholder-elevator-group).

            The 'elevatorGroup' block only makes sense in the 'add' array.  The 'update' array is for
            changing the cardholder's default floor and passenger types on an existing elevator group
            assignment.

            The server will ignore all fields in the elevatorGroup and accessZone objects except 'href'
            if you place them in the body of your PATCH.

            Remove the default floor in an update by supplying an accessZone block with the href set
            to null or "".

            Change a passenger type in an update by supplying the new value. The passenger type will
            be unchanged otherwise.

            As with cards and access group memberships etc., the server ignores root-level hrefs in
            the elements of an 'add' array, requires them in the 'update' array (since they indicate
            the entries to work on), and ignores everything but them in the 'remove' array.

            The example shows our cardholder receiving a default floor for one elevator group and
            updating the Code Blue and VIP passenger types for another elevator group.

            Added in 8.50.
          example:
            add:
              - elevatorGroup:
                  href:  "https://host.com:8904/api/elevator_groups/635"
                accessZone:
                  href:  "https://host.com:8904/api/access_zones/637"
            update:
              - href: "https://host.com:8904/api/cardholders/325/elevator_groups/1268613268"
                enableCodeBlueFeatures: true
                enableVipFeatures: false
            remove:
              - href: "https://host.com:8904/api/cardholders/325/elevator_groups/3498734"

    CardholderChanges:
      title: Cardholder changes
      description: |
        An array of cardholder changes, described in the next section, and a `next` link for more.
      properties:
        results:
          type: array
          description: An array of cardholder changes.
          items: { $ref: '#/components/schemas/CardholderChange' }

        next:
          type: object
          description: |
            The link to the next page of changes.  This will always be present, because (unlike items)
            changes never run out.

            Because the `next` link is a pointer to the head of a queue of changes, and new changes
            are being added to that queue which will not suit your filter or privileges, it will
            change even when there are no results.

            Therefore you should always use this link for your next query.  Do not be tempted to
            re-use a URL after `results` comes back empty, thinking you merely need to ask the same
            question again.  Doing that will cause the server unnecessary work, skipping over changes
            that did not pass your filter or privilege checks on the previous call.

          properties:
            href: { type: string, format: uri-reference }
          example:
            href: "https://host.com:8904/api/cardholders/changes?pos=SWEp9"

    CardholderChange:
      title: Cardholder change
      description: |
        `/api/cardholders/changes` returns an array of these.  Each contains a description of a change
        made to a cardholder.

        In this example a cardholder has had his name changed from Craig to Gavin, has had an
        enablement date set on a competency, and has had a card and access group membership added.

        ### Notes

        - Changes to an access group membership will have a different href in the `oldValues` and
          `newValues` blocks, because modifying a group membership changes its ID.

        - The API will not notify changes to a competency's `credit` integer or `limitedCredit`
          boolean.  These fields are part of a separate Command Centre feature and are not supported
          by the changes API.

        - The API will report a spurious change to a PDF value when a cardholder rejoins an access
          group he or she was previously a member of, provided that access group carried a PDF with no
          default and the cardholder did not have a value for it.

        - This API will not notify changes to `lastSuccessfulAccessTime` or
          `lastSuccessfulAccessZone`.

      properties:
        href:
          type: string
          format: uri-reference
          description: |
            Command Centre's identifier for this change.  This has no use in the API:  you cannot use
            it as a URL, but you may like to use it to track the changes you have seen.
          example: "https://host.com:8904/api/cardholders/changes/f4e67a"
        time:
          type: string
          format: date-time
          description: The time that this change occurred.
          example: "2020-01-14T03:14:33Z"
        type:
          description: |
            'add' if this change added a cardholder, 'update' if it modified a cardholder, or 'remove'
            if it deleted a cardholder.
          type: string
          enum: [ add, update, remove ]
          example: "update"
        item:
          description: |
            A block containing the href of the changed cardholder.  You can GET this URL to find the
            cardholder's current state, or you could add the cardholder block to the change using
            `fields=cardholder` in the query.  Note that you can add individual cardholder fields such
            as PDFs using `fields=defaults,cardholder.personalDataFields`.
          type: object
          example: {"href":"https://host.com:8904/api/cardholders/525"}
        operator:
          description: |
            A block containing the href and current name of the operator who made this change.

            Because building this block requires more work from the server it is not in the default
            field set.  If you need it you must ask for it using the fields parameter:
            `fields=defaults,operator`.
          type: object
          example: {"name": "System Operator", "href": "https://host.com:8904/api/items/1"}
        oldValues:
          description: |
            A block containing the values of the changed fields before the change, if Command Centre
            still has them, in the same format as a [cardholder
            detail](#definition-Cardholder-detail).  If a value is blank, it means that the value was
            null before the change or the server no longer has it.

            Because this requires extra effort from the server, you may like to omit this block using
            something like `fields=time,type,item,operator` unless you are particularly interested in
            historical data.

          example:
            firstName: "Craig"
            competencies:
            - "enablement": ""
              "href": "https://host.com:8904/api/cardholders/525/competencies/3910e4"
        newValues:
          description: |
            A similar block containing the values of the changed fields after the change, if the
            server has them.

            Generally, this block is less useful than the current state of the cardholder, described
            next.  It also requires extra effort from the server, so you may like to omit this block
            using `fields`.

          example: {
            firstName: "Gavin",
            competencies: [
              {
                "enablement": "2020-02-29T00:00:00Z",
                "href": "https://host.com:8904/api/cardholders/525/competencies/3910e4"
              }
            ],
            cards: [
              {
                "number": "2",
                "cardSerialNumber": "",
                "issueLevel": 1,
                "from": "",
                "until": "",
                "href": "https://host.com:8904/api/cardholders/525/cards/285f779af1ef49abbba"
              }
            ],
            "accessGroups": [
            {
            "accessGroup": {
              "name": "Access Group 1",
              "href": "https://host.com:8904/api/access_groups/499"
              },
              "from": "",
              "until": "2020-01-15T04:39:00Z",
              "href": "https://host.com:8904/api/cardholders/525/access_groups/f9cb328b4"
              }
            ] }
        cardholder:
          description: |
            A block containing the current fields on the cardholder, provided the cardholder has not
            been deleted.  This is in the same format as a [cardholder
            detail](#definition-Cardholder-detail).

            Because building this requires more work from the server it is not in the default result
            set.  If you need it you must ask for it using the `fields` parameter.  While the server
            has a default field set for cardholders, your query will be more efficient if you ask for
            just the fields you need:
            `fields=defaults,cardholder.firstName,cardholder.lastName,cardholder.cards`, etc.  Note
            how you must prefix each field with `cardholder` since they are all inside a block with
            that name.
          example: {
            firstName: "Gavin",
            cards: [
              {
                "number": "2",
                "cardSerialNumber": "",
                "issueLevel": 1,
                "from": "",
                "until": "",
                "href": "https://host.com:8904/api/cardholders/525/cards/285f779af1ef49abbba"
              }
            ] }

    HexString:
      type: string
      pattern: '^0x([0-9A-Fa-f]{2})+$'
      example: "0x0123456789ABCDEF"
    Url:
      type: string
      format: uri

    DesfireEncodingRequest:
      type: object
      properties:
        csn: { $ref: '#/components/schemas/HexString' }
        cad:
          $ref: '#/components/schemas/HexString'
      required: [csn]
      description: |
        - `csn`: Card serial number (UID).
        - `cad`: Gallagher Application Directory bytes as hex. Required if CAD exists on card.

    DesfireFile:
      type: object
      properties:
        data: { $ref: '#/components/schemas/HexString' }
        accessRights: { $ref: '#/components/schemas/HexString' }
      required: [data, accessRights]
    DesfireKey:
      type: object
      properties:
        name: { type: string }
        data: { $ref: '#/components/schemas/HexString' }
      required: [data]
    DesfireApplication:
      type: object
      properties:
        name: { type: string }
        keys:
          type: object
          description: Map of key number or name to key details.
          additionalProperties:
            $ref: '#/components/schemas/DesfireKey'
        keySettings1: { $ref: '#/components/schemas/HexString' }
        keySettings2: { $ref: '#/components/schemas/HexString' }
        files:
          type: object
          description: Map of file number to file content/access rights.
          additionalProperties:
            $ref: '#/components/schemas/DesfireFile'
      required: [files]
    CallbackLink:
      type: object
      properties:
        href:
          type: string
          description: Absolute or relative URL for callback invocation.
      required: [href]
    CallbackLinks:
      type: object
      properties:
        encodeCompleted: { $ref: '#/components/schemas/CallbackLink' }
        encodeFailed: { $ref: '#/components/schemas/CallbackLink' }
      required: [encodeCompleted, encodeFailed]
    DesfireEncodingResponse:
      type: object
      properties:
        applications:
          type: object
          description: Map of application id to application details.
          additionalProperties:
            $ref: '#/components/schemas/DesfireApplication'
        callback: { $ref: '#/components/schemas/CallbackLinks' }
      required: [applications, callback]

    ClassicBlocks:
      type: object
      description: Map of block index to data block bytes.
      additionalProperties:
        $ref: '#/components/schemas/HexString'
    ClassicCad:
      type: object
      properties:
        sector: { type: integer }
        blocks: { $ref: '#/components/schemas/ClassicBlocks' }
      required: [sector, blocks]
    ClassicMad:
      type: object
      properties:
        blocks: { $ref: '#/components/schemas/ClassicBlocks' }
      required: [blocks]
    ClassicEncodingRequest:
      type: object
      properties:
        csn: { $ref: '#/components/schemas/HexString' }
        cad: { $ref: '#/components/schemas/ClassicCad' }
        mad: { $ref: '#/components/schemas/ClassicMad' }
        unavailableSectors:
          type: array
          items: { type: integer }
      required: [csn]
      description: |
        - `csn`: Card UID.
        - `cad`: Gallagher Application Directory sector/blocks (required if present on card).
        - `mad`: MAD bytes (required if present on card).
        - `unavailableSectors`: Sectors already occupied or reserved.
    ClassicSector:
      type: object
      properties:
        name: { type: string }
        data:
          allOf:
            - $ref: '#/components/schemas/HexString'
          description: Optional sector trailer or aggregate data if returned.
        blocks: { $ref: '#/components/schemas/ClassicBlocks' }
      required: [blocks]
    ClassicEncodingResponse:
      type: object
      properties:
        sectors:
          type: object
          description: Map of sector number to sector data/blocks.
          additionalProperties:
            $ref: '#/components/schemas/ClassicSector'
        callback: { $ref: '#/components/schemas/CallbackLinks' }
      required: [sectors, callback]

    ErrorMessage:
      type: object
      properties:
        message: { type: string }
  securitySchemes:
    API_key:
      type: apiKey
      name: Authorization
      in: header
      description: happykey description
    basic:
      type: http
      scheme: basic
      description: |
        HTTP Basic authentication using a blank username and the API key as the password.

info:
  x-logo:
    url: gallagher.png
  title: "Command Centre REST API"
  version: "1.0"

  description: |

    This document describes how you can use the Command Centre REST API to view and manage access
    zones, alarm zones, elevator groups, fence zones, doors, macros, inputs, and outputs.

    This is a self-referencing REST API that follows the principles of HATEOAS.  Other than the
    initial `GET /api` when it first connects, your source code should not contain any URLs,
    as they are subject to change.  You should append the query parameters this document describes
    for operations such as filtering and searching, but everying in the path should come from the
    results of `/api` or pages linked from it.

    `/api` only shows the API calls the server is licensed for.

    Be prepared to append query parameters to URLs that already have their own:  do not assume
    that you can simply add a question mark and your parameters.

    Any behaviour of that is not referenced in this documentation is subject to change.  This
    includes routes (URLs), default values, request parameters, and HTTP verbs, among others.

    In particular:

      * If you discover a route or query parameter that is not documented here, a future version may
        change its behaviour.

      * Take all 2xx responses as success and all 4xx responses as failure.  Example: a success
        could be 200 or 204 depending on whether it has something to tell you, and a negative result
        will change between the various 400s depending on the environment.

      * Treat items IDs as strings even though they are currently look like small integers.  We
        intend to change them.

      * Treat string identifiers as strings even if they look like GUIDs.  If the documentation does
        not say they will always be a GUID, they may not.

      * Some routes work with a PATCH even though they should only accept a POST.  One day, PATCHes
        to those routes will start to fail.

      * Format all timestamps as specified in the documentation.  The parser we currently use is
        quite flexible, so you may find that other formats ( "1/12/2025" ) work today but not
        tomorrow.

    ## Links to intro sections.

    [Rapidoc intro section link](#overview--forward-compatibility-hateoas)
    
    [Redoc intro section link](#section/Forward-compatibility-(HATEOAS):)

    [OpenAPI Explorer intro section link to hateoas](#section/Forward-compatibility-(HATEOAS):?route=overview--forward-compatibility-hateoas) doesn't work

    [OpenAPI Explorer intro section link to 'testing internal links'](#section/Forward-compatibility-(HATEOAS):?route=overview--testing-internal-links)

    ## Links to access groups tag
    
    [Rapidoc path link](#get-/api/access_groups)
    
    [OpenAPI Explorer path link](#?route=tag--Access-groups) access groups tag
    
    [Redoc path link](#tag/Access-groups/paths/~1api~1access_groups/get)
    

    ## Links to access group detail schema
    
    [Rapidoc schema link](#cmp--schemas-accessgroupdetail) (only good in focussed mode)

    [OpenAPI Explorer schema link](#?route=cmp--schemas-accessgroupdetail)

    Redocly does not show components on their own.

    ## Links to paragraphs.
    
    [Rapidoc description paragraph link](#tag--Cardholders--field-names-in-query-parameters).

    [Rapidoc read mode description paragraph link](#field-names-in-query-parameters) same as redoc!

    [Redoc description paragraph link](#field-names-in-query-parameters).

    Can't see how to link to paragraph anchors in OpenAPI Explorer (but they are named same as Redoc).

    What you can do with the `fields` query parameter on an events method has improved through the
    versions, so explaining it is a topic in itself.

    In 8.40 and later the values you can list are the same as the field names in the [details
    page](#definition-Event-detail), plus the special value for a personal data field described
    below.  You can pick whichever fields you want, including `defaults`, though we urge you to
    only list the fields you need.  Anything you wrote for 8.30 or earlier will
    work in 8.40 as it did before.

    In versions up to 8.30 you can only add fields to the event summary and details pages, not
    remove them.  If you send the parameter it must start with `fields=defaults`.  That gives you
    the default set.  What you can add after that depends on the version of Command Centre you're
    calling.

    In 8.10 and earlier the only field you can add is `cardholder.pdf_XXXX`, where XXXX is the ID
    of a PDF.  Find that ID with a query to the [PDFs
    controller](cardholders.html#operation--api-personal_data_fields-get).  Don't forget a
    separating comma between it and `defaults`.

    That will add a cardholder's PDF to the events that are related to them.

    You can only pick one PDF.  It will only appear on events that have a related cardholder, such
    as access events, because without a cardholder there is no PDF.  The security model applies
    too, so it will only appear if your REST operator has the appropriate privileges on that
    cardholder and PDF.

    In 8.20 and 8.30 you can also add `details`.  Make sure you have a separating comma after
    `defaults` or `cardholder.pdf_XXXX`.

    An event detail string can be kilobytes long so we left it optional.  It is the only field in
    the details page that is not in the search results, by the way, so if you are running 8.20 or
    later you can add it to your search results and you will not need the details page.

    | Server version | Valid fields parameter values
    | ------------ | --------------
    | Older than 8.20 | defaults,cardholder.pdf_XXXX 
    | 8.20 to 8.30 | defaults,cardholder.pdf_XXXX<br>or<br>defaults,details<br>or<br>defaults,cardholder.pdf_XXXX,details
    | 8.40 and later | any

    ## Per-event bookmarks

    If you are running 8.70 or later and you put `previous`, `next`, or `updates` in the field
    list of an event search, the server will add those fields to each event.  All server versions
    include links with those names at the end of results, but they are not useful if you crash out
    half way through processing a batch.  The per-event links, only available in 8.70 and later
    and only on request, give you a place to pick up from without being re-sent the events you
    already processed.

    First, some background on operators, operator groups, and divisions.

    To determine your REST client's privileges, the server starts by searching the list of REST
    Client items in its configuration for the one with the API key in the `Authorization` header of
    your request.  Assuming it finds one, it takes the cardholder from that REST Client item.

    To be any use at all that cardholder must be a member of at least one operator group.  Being
    in an operator group makes a cardholder an _operator_.

    After the server has your operator, it needs to check whether that operator has access to the
    items or events in the request.  To explain that, it is necessary to cover divisions.

    Aside from some special items such as day categories, every item in Command Centre is in a
    _division_.  Divisions are hierarchical, with all divisions (but the root) being a child of
    another.  Multi-server installations have one division tree per server.

    Every event and alarm has a division.  It is usually the division of the source item.  Card
    events or 'forced door' alarms, for example, typically use a door as a source item; when an
    operator modifies an item, the event recording that change uses that operator's workstation as
    the source item; the alarm that the server generates when you send a bad API key uses the
    server item as the source.

    An event's division is not always its source's division.  'Card activated' events have the
    server as a source item, but take on the cardholder's division so that operators who can see
    the cardholder can also see when the server activates their cards.

    To link privileges to items and events, an operator group contains a list of privileges and a
    list of divisions.  Its operators enjoy those privileges on all the items, events, and alarms
    that are in those divisions.

    Having a privilege on a division also grants an operator that privilege on that division's
    descendants.  Therefore an operator with a privilege on the root division has that privilege
    on all that server's items and events.

    A common misconception is that the division an operator is in, or the division an operator
    group is in, have a bearing on the operator's privileges.  They do not.  It is all about the
    divisions in the operator group's 'Operator privileges' list.

    ## If your privileges do not seem to be working

    First, to protect Command Centre from accident and malice, you should strive to grant your
    REST clients the fewest and lowest-level privileges you can.  Do not give them 'advanced
    user'.  Reaching a point where you do not receive the results you want is a good thing:
    it means you have screwed things down a little too tightly.

    **If changing privileges in Command Centre does not seem to make any difference**, remember to
    push the 'Refresh operator privileges' button in the properties window of your REST Client
    item.

    Here are some general rules that may help if you are still not receiving the results you
    expect.

    - Receiving a 403 from a GET means the server may not have a license for the retrieval you are
      attempting or your operator does not have the privilege to view that object.  If it is a
      licensing problem, the body of the response will describe it.

    - Receiving a 403 from a PATCH, POST, or DELETE means your operator does not have the
      necessary privilege to perform that operation.  You need one of the privileges beginning
      with 'Edit', 'Modify', or 'Create'.

    - Receiving a 404 when trying to get one item or event means it either does not exist or your
      operator does not have the privilege to view it.

    - Receiving a 200 and an empty result set from a search means you are licensed for that search
      but your operator could not see any items or events that matched.  One possible cause is
      that your operator is not licensed to see _any_ items or events of that kind.  Make sure
      that one of the operator groups that your operator is in has a 'View' privilege such as
      'View events' or 'View cardholders' - whatever is appropriate.  If it does, and you have hit
      the button mentioned above, then check that the divisions on the operator group contain the
      items you expect.  If it is events you are searching for, check the source item on those
      events either by using a REST operator with 'View events' on the root division or by looking
      at them in one of the thick clients.

    Command Centre's REST API encodes all payloads using UTF-8, and expects clients to do the
    same.  It does not escape special characters in response bodies except where required to embed
    them in JSON.

    Specifically, it does not sanitise HTML, XML, or SQL.  Your clients should expect to receive
    strings exactly as they were sent, even if they were sent by a hostile client.  Write your
    clients to resist injection attacks.

    Most items have a status.  Access zones, for example, can be in one of a few different modes,
    and have a _zone count_ that rises and falls with cardholders arriving and leaving.  Inputs
    and outputs can be on or off.  Any item can be in an unknown state when the REST server is out
    of touch with its hardware.  Et cetera.

    The REST API can send an item's status to you in a string ready for human consumption in a UI,
    or as a list of flags more suitable for an integration.  Neither of those fields are on an
    item's summary or details pages by default; to obtain them reliably you need to subscribe to
    updates.

    ## Subscribing to status updates

    The server does not always have an item's status:  to prevent unnecessary work on the
    controller, network, and server, it will stop requesting updates when nothing is subscribed to
    them.  It is very important that items stay in touch with their controllers, and controllers
    with each other, but it is normal for controllers to limit what they send back to the server.

    The server will be up to date when one of the following happened recently:

    - an operator had the item visible in the Configuration, Command Centre, or mobile clients,
    - an application monitored the item via another API,
    - a REST client used the item in a [status subscription](events.html#status-subscriptions), or
    - a REST client followed the item's `updates` link from its details page.

    If it is not up to date and you request the status on an item's summary or details page, the
    server will report that the status is unknown.

    To retrieve the status of one item you should GET the item's `updates` link from its details
    page.  To monitor the status of many items you should use the [status subscription
    API](events.html#status-subscriptions) on the items controller (added in 8.30).

    Whichever API you use, if the server does not have an item's status when you ask it will
    request an update from the item itself.  For hardware items that may involve a conversation
    with another server, a hardware controller, and another piece of hardware on the end of a
    serial line.  That all takes time, but the server answers you immediately, so the first
    response you receive may be 'unknown'.  The status request continues in the background.

    No matter what you receive, you should follow the `next` link in a loop until it gives you a
    status you are looking for, or another status indicating why it cannot.  Your original request
    started a subscription, which every subsequent request refreshes, so while you stay in that
    loop the server will have the item's current status for you and all other callers.

    The first status you will receive after 'unknown' will probably be 'controller unknown', which
    means that the controller (or other hardware) has received the server's request but does not
    yet have an answer, because of that serial line.  You need something better, so stay in the
    loop.

    ## Staying current

    When you use the `updates` link on the item's details page it will return immediately.  When
    follow the `next` link in the page it returns, it will send back the status straight away if
    it changed since your previous call, or block until it does change.  If nothing happens within
    a minute or so, it will return with no updates.

    Whether you received an update or not, the body will contain a `next` link for you to follow
    for the next update.

    State changes are not queued:  the API only keeps the last, so it only takes one call to get
    yourself up to date with the server.  Remember that the server itself may not have been up to
    date, and your making the call will have started it on its own little journey of discovery,
    which will cause more updates.

    The 'Site' tab of the sample application shows this in operation.

    ## For a user interface

    The `statusText` field describes the state of the item in a multi-line string taken from the
    server's language pack.  The natural state of a door, for example, is

    <pre>
    Closed, locked, secure access.
    </pre>

    A fence zone's status text could be

    <pre>
    On - HV.
    Voltage: 8.2 kV.
    Seven day High Voltage min to max: 0.1kV to 9.8kV.
    Pre-arm check while Alarm Zone is arming.
    </pre>

    For one-line display, the `status` field is the same thing with spaces instead of line
    endings.

    Neither of these is intended for integrations.  By all means display them in a user interface
    (as Gallagher software does) but do not attempt to parse information out of them.

    ## For an integration

    The `statusFlags` field contains an array of string enumerations (flags) that describe the
    item's condition in a reliable and machine-readable way.

    Each item type has a different set of flags.  Some overlap (doors, inputs, and outputs can all
    be closed, for example) but most flags apply to only one kind of item.  The common exceptions
    are the flags which indicate why the server cannot return the item's actual status, covered
    next.

    ### Abnormal status flags

    These are the status flags that indicate the server does not have the current status of the
    item:

    - `unsaved` and `deleted` are transient conditions you should not encounter in normal use.
      Either way, the item is in no condition to query.

    - `unconfigured` is very common while a site is being set up.  It means the item is not fully
      configured yet.  An access zone is not configured until it has at least one door, for
      example.

    - `remoteServerOffline` is only possible in a multi-server setup.  It means that the item is
      remote (on a different server) and the server answering your REST query cannot reach it.

    - `processOffline` means the Controller service that is meant to be running on the Command
      Centre server, and handling all the communications with hardware controllers, is not.

    - `controllerOffline` means the software on the server is as it should be but the hardware
      controller (such as a C6000) is offline.  That could mean it needs its certificate
      revalidated, or just that its power or networking is out.

    - `notPolled` means the item is shunted:  Command Centre is ignoring the item's
      communications at the request of an operator.  You normally do it to stop spurious alarms.

    - `deviceNotResponding` means exactly that.  It means the server is in contact with the
       hardware controller, but there is a problem between there and the item.  Probably a cable
       fault, unless `encryptionKeysTampered` accompanies it.

    Those are fault conditions.  If you see one of those, there is a configuration or hardware
    fault or a shunt preventing the server communicating with the item.

    They are in priority order:  if you receive one near the bottom of the list you can take heart
    in the knowledge that your item is suffering none of the preceding abnormalities.

    There are two more flags that are common to most item types.

    - `unknown` means everything else is in order but you caught the server in a period when it
      simply had no need to stay in touch with the item.  You will get this on a summary or
      details page, because they do not subscribe to updates for the item.  The 'updates' link
      will not send you this status flag.

    - `controllerUnknown` is a transient state, hopefully.  The 'updates' call often returns it
      the first time if the server does not have the item's status already.  It means a component
      (such as a hardware controller) between the server and your item is working on bringing in
      an update.  This generally resolves quickly, so if you follow the 'next' link you will
      receive the latest status.

    The server will not send any other flags with one of those eleven, apart from the possible
    pairing of `encryptionKeysTampered` and `deviceNotResponding`, and some unusual combinations
    noted later.

    Do not go looking for all of the abnormal status flags above and assume the best if they are
    not there.  Gallagher may add more fault conditions in future versions of the API.

    Instead, read each item's section under Operations for what its flags will be when it is
    online.  A paragraph called "flag rules" shows how you can tell if the item is in a correct
    state.  For the impatient:  doors, inputs, and outputs will be open or closed, fence zones
    will be on or off, and alarm and access zones will be in one of four zone states.

paths:

  /api/cardholders:

    get:
      tags:
      - Cardholders
      summary: Search cardholders
      description: |
        This call returns cardholders matching your search criteria.

        The result will contain no more than 100 or 1000 cardholders depending on your version; you
        should follow the `next` link, if it is present, to collect the next batch.

        When you have loaded all the cardholders there will be no `next` link.

        If your result set is empty it means your operator does not have the privilege to view any
        cardholders.  Perhaps there are none in the divisions in which your operator has privileges,
        or your operator has no privileges at all.

        Adding or modifying cardholders between calls to this API will not affect the pagination of
        its results if you sort by ID.

        [Do not code this URL](#topic-Forward-compatibility--HATEOAS-) into your application.  Take it from the 'href' field in the
        `features.cardholders.cardholders` section of `/api`.
      parameters:
      - $ref: '#/components/parameters/sort'
      - name: top
        in: query
        description: |
          Sets maximum number of cardholders to return per page.

          Older versions of Command Centre returned 100.  That is acceptable for a GUI application
          that will only display the first page of cardholders, but for integrations that intend to
          proceed through the entire database it causes a lot of chatter.

          Version 8.70 will return 1000 items per request by default.  1000 is about where a graph
          of performance versus page size begins to level out.  You may see some improvement by
          taking it even higher.
        schema:
          minimum: 1
          type: integer
      - name: name
        in: query
        description: |
          Limits the results to cardholders with a name that matches this string.  By default, it is
          a substring search against the first name or the last name or the concatenation
          'lastName, firstName'; surround the parameter with double quotes `"..."` for an
          exact search.

          Without quotes, a percent sign `%` inside your search string will anchor the search at
          both ends (so it will no longer be a substring search) and the `%` will match any
          substring.  For example, `boothroyd,%` will only match cardholders whose last name is
          Boothroyd.

          The search is always case-insensitive.  Results are undefined if you do a substring search
          for the empty string (`name=`).  You will receive no cardholders if you search for those
          with no name (`name=""`), as all items must have a name.

          Because a plus sign `+` represents a space in a query string, replace each plus sign in
          your search string with `%2d`.

          The search parameters form a logical conjunction.  They are ANDed
          together.  Therefore if you search for `name=Mary&pdf_1315=nanny` you will only get back
          cardholders with 'Mary' in their name and 'nanny' in the PDF with ID 1315.
        schema:
          type: string
      - name: "pdf_{id}"
        in: query
        description: |
          Limits the results to cardholders with a value for the Personal Data Field with this ID
          that matches the parameter.

          It is a substring match by default; surround it with double quotes `"..."` for an exact
          match.  Tests showed an exact match to be 100x quicker than a substring search on a large
          database.

          Without quotes, `_` will match any single character and `%` will match any substring.
          Having either in your term will anchor the string at both ends so it will not be a
          substring search.  A lone `%` will return any cardholder who has this PDF set to a
          non-null value.

          Searching for a blank value using `pdf_xxx=""` or `pdf_xxx=` currently matches no
          cardholders, which is not useful.  Do not rely on that behaviour since we will change it
          in a future version of Command Centre to return cardholders with no value for that PDF.

          Because a plus sign `+` represents a space in a query string, turn plus signs in your
          string into `%2d`.

          The search is always case-insensitive.

          Search parameters form a logical conjunction.  They are ANDed
          together.  Therefore the search `pdf_1315=nanny&pdf_1315=paratrooper` will only return
          cardholders whose PDF 1315 contains the strings 'nanny' and 'paratrooper'.
        schema:
          type: string
      - $ref: '#/components/parameters/division'
      - $ref: '#/components/parameters/directDivision'
      - $ref: '#/components/parameters/description'
      - name: accessZone
        in: query
        description: |
          Limits the results to cardholders who are in one of the access zones with the given IDs.
          Do not put quotes around the IDs, and separate them with commas.

          To get everyone who is in _any_ access zone use `accessZone=*`.  It will return all
          cardholders who have badged at least once and who are not currently 'outside the system'.
          A cardholder is 'outside' if they badge through a door that has no access zone configured for that direction of travel,
          or if an operator manually moves them outside.
        style: form
        explode: false
        schema:
          type: array
          items:
            type: string

      - name: fields
        in: query
        description: |
          Specifies the fields you want in the search results.  The values you can use here are the
          same as you can for the [details page](#operation--api-cardholders--id--get).
          Using it you can return everything on the search page that you would find on the details
          page with the exception of the `edit` and `updates` links.  Separate values with commas.

          Use the value `cards.encodingData` to receive links to the methods that return
          card-encoding data.

          Use the special value `defaults` to return the fields you would have received had you not
          given the parameter at all.  Obviously only do that if you have more to add.

          Use the special value `personalDataFields` to return the 'personalDataDefinitions' block
          as well as the PDF values at the root level of the cardholder object.

          Use the special value `pdf_XXX` (where `XXX` is the ID of a PDF definition) to include
          just that PDF.  If you do not have the PDF's ID, and don't mind the performance hit of
          retrieving all the PDFs, using `personalDataDefinitions` may be simpler.

          There is a special value `defaults` which adds everything you would have received had you
          not sent a `fields` parameter at all, but we advise against its use:  specifying every
          field you want makes the response more predictable across different server versions.

          Treat the string matches as case sensitive:  use 'lastName' rather than 'lastname'.

          In v8.00 you will receive the href and internal ID even if you do not ask for them.  In
          8.10 you will not.  If you are going to send the fields parameter and need the href or ID,
          include them.
        style: form
        explode: false
        schema:
          type: array
          items:
            type: string
          default: defaults
      - $ref: '#/components/parameters/pos'
      - $ref: '#/components/parameters/skip'
      responses:
        "200":
          description: |
            Success.  See the note in the description about privileges if your result set is empty.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CardholderSearch'
        "400":
          description: The server could not make sense of your search terms.
          content: {}
        "403":
          description: The site does not have the RESTCardholders licence.
          content: {}

    post:
      tags:
      - Cardholders
      summary: Create a cardholder
      description: |
        This creates a new cardholder, including his or her cards, group memberships, personal data,
        competencies, and roles.

        [Do not code this URL](#topic-Forward-compatibility--HATEOAS-) into your application.  Take
        it from the 'href' field in the `features.cardholders.cardholders` section of `/api`.

        The POST expects a document in the same format as the [the cardholder
        detail](#definition-Cardholder-detail).  Many fields are optional, of course, and
        some (like the last successful access time) do not make sense when creating a
        cardholder.  See the [cardholder POST
        example](#definition-Cardholder-POST-example) for details.

        You will achieve better performance if you combine all you want to achieve into one POST,
        rather than creating the cardholder bare with a POST then adding cards, groups, PDFs, etc.,
        with PATCHes later.

        When successful it returns a location header containing the address of the new cardholder.

        Note that you can only create one cardholder per POST.
      requestBody:
        description: |
          This can be a large object as shown, or a tiny one, because the only fields you must
          have in the POST are the division and either the first or last name.
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CardholderPOST'
            examples:
              Sample POST:
                $ref: '#/components/examples/CardholderPOSTExample'
              Mobile credential:
                $ref: '#/components/examples/CardholderPOSTCardMobileExample'
              Physical card:
                $ref: '#/components/examples/CardholderPOSTCardPhysicalExample'
        required: true
      responses:
        "201":
          description: |
            Success.
          headers:
            location:
              description: The href of the new cardholder.
              schema:
                type: string
                format: uri-reference
          content: {}
        "400":
          description: |
            The body of the POST did not describe a valid cardholder.

            If you see 'Data has not been entered for this Personal Data Field' in the
            response body, you have attempted to create a cardholder in an access group
            that has a required Personal Data Field, but not supplied a value for that
            PDF.

            If you see 'Invalid cardholder', the server could not parse the JSON in the body of your
            POST.  Remember to quote all strings, especially those than contain @ symbols.
          content: {}
        "403":
          description: |
            The operator does not have a privilege that allows creating cardholders, or you
            attempted to set a field for which the operator has no privilege (probably 'notes'), or
            the server has reached its licensed limit of cardholders.
          content: {}
      x-codegen-request-body-name: not rendered

  /api/cardholders/{id}:
    parameters:
      - $ref: "#/components/parameters/id"
    get:
      tags:
      - Cardholders
      summary: Get details of a cardholder
      description: |
        This retrieves one cardholder from Command Centre.  It does not return all the fields
        available (there are too many) so, much like the cardholder search, it accepts a `fields`
        parameter where you specify the fields you need.

        [Do not use](#topic-Forward-compatibility--HATEOAS-) a
        cardholder's ID to build the URL yourself:  follow the href in the [cardholder
        search](#definition-Cardholders) to get here.

      parameters:
      - name: fields
        in: query
        description: |
          Specifies the fields you want in the results.  The values you can list are the same as the
          field names in the [detail results](#definition-Cardholder-detail).  Use it to return
          fewer fields than normal.  Separate values with commas.

          Treat the string matches as case sensitive:  use 'lastName' rather than 'lastname'.

          Added to the cardholders controller in 8.00.  In that version you will receive the href,
          internal ID, and updates link even if you do not ask for them.  In 8.10 you will not.  If
          you are going to send the fields parameter and need those fields, include them.
        style: form
        explode: false
        schema:
          type: array
          items:
            type: string
          default: defaults
      responses:
        "200":
          description: Success.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CardholderDetail'
        "404":
          description: |
            That is not the URL of a cardholder, or the operator does not have the privilege to view
            that cardholder.
          content: {}

    patch: 
      tags: [ Cardholders ]
      summary: Update a cardholder
      description: |
        This is the call you use to update a cardholder, including:
          - changing general properties such as names, division, and description,

          - changing PDF values, and

          - adding or updating cards, access group membership, roles and relationships, lockers, and
            competencies.

        When changing a cardholder's division at the same time as PDFs or competencies, the extra
        privilege checks required for PDFs and competency changes use the origin division, not the
        destination division.  So if you are moving a cardholder from a division in which your
        operator has no access to PDFs and competencies into one in which it does, first PATCH the
        cardholder into the new division then PATCH it with the other changes.

        You can find this URL in the href in the [cardholder search](#definition-Cardholders) or
        any of the other calls that return cardholder hrefs.  [Do not build it
        yourself](#topic-Forward-compatibility--HATEOAS-).
        
        ---
          
        Note that the REST API does not implement the full suite of Command Centre
        privileges.  In particular, the following privileges do not have the same effect
        on an operator's ability to modify a cardholder that they do in the administrative
        clients:

          - Disable Card.  This privilege has no effect on the 7.90 REST API.  You need
            Edit Cardholders to disable cards.

          - Add or Edit Cardholder Notes.  You also need Edit Cardholders to change notes
            on an existing cardholder via the API.  In the administrative clients, you do
            not.

          - Manage Locker Assignments.  You also need Edit Cardholders to assign and un-assign
            lockers on a cardholder via the API.  In the administrative clients, you do not.

        The 'De-authorise Cardholder' privilege _is_ implemented.  It allows an operator to set a
        cardholder's 'authorised' field to false (denying all their future access requests) without
        the Edit Cardholders privilege.

        In short, if your application intends to do more to cardholders than de-authorise them, you
        will need an operator with Edit Cardholders.

        ---
          
        The PATCH is best illustrated by example.

      requestBody:
        description: |
          As well as cardholder attributes such as 'authorised', the PATCH body contains
          instructions for creating, updating, and deleting personal data, group
          memberships, etc.
        content:
          application/json:
            examples:
              Physical card:
                $ref: '#/components/examples/CardholderPATCHCardPhysicalExample'
              Mobile credential:
                $ref: '#/components/examples/CardholderPATCHCardMobileExample'
        required: true

      responses:
        200:
          description: |
            Success.  Future versions will add feedback from the server about your PATCH.
        204: 
          description: "Success, with no feedback."
        400:
          description: |
            The parameters are invalid, or other errors prevented the update.

            If you receive 'No fields have been defined for update', check that your submission body
            is valid JSON.
        403:
          description: |
            The site does not have a RESTCardholders licence, or you attempted to set a PDF for
            which you have no privilege.
        409: *409CH
        4xx:
          description: |
            The operator does not have the privilege to modify that cardholder, or you attempted to
            set a field for which you have no privilege (such as 'notes' or 'operatorPassword', both
            of which require special privileges).  In versions prior to 8.80 your operator needed
            'Edit cardholders' to de-authorise a cardholder.  In 8.80 and later, 'De-authorise
            cardholder' on its own is enough.

          
    delete:
      tags:
      - Cardholders
      summary: Remove a cardholder
      description: |
        This call removes a cardholder from Command Centre.  You can find the URL in the href in the
        [cardholder search](#definition-Cardholders) or any of the other calls that return
        cardholder hrefs.  [Do not build it yourself](#topic-Forward-compatibility--HATEOAS-).

      responses:
        "200":
          description: Success.
          content: {}
        "204":
          description: Success.
          content: {}
        "400":
          description: |
            Deleting the cardholder failed.  This happens when the cardholder is a critical part of
            another construct (a personalised notification, for example).
          content: {}
        "403":
          description: |
            The operator does not have permissions to delete that cardholder
            or the server is not licensed for cardholder operations.

            In versions up to and including 9.20 403 also means that there is no such cardholder.
          content: {}
        "404":
          description: |
            New in 9.30.  There is no such cardholder.
          content: {}
        "409":
          description: |
            The cardholder is locked for editing by another operator.  The body of the response will
            tell you which operator is holding the lock.
          content: {}

  /api/cardholders/{id}/access_groups/{secondary_id}:
    parameters:
    - $ref: "#/components/parameters/id"
    - $ref: "#/components/parameters/secondary_id"

    delete:
      tags:
        - Cardholders
      summary: Remove an access group membership

      description: |
        This call removes a cardholder's membership in an access group.  Note that a cardholder may
        have more than one membership in a group.

        You can find this URL in the [cardholder object](#definition-Cardholder-detail).  [Do not
        build it yourself](#topic-Forward-compatibility--HATEOAS-).

      responses: 
        204: 
          description: "Success."
        403:
          description: |
            The operator does not have a privilege that allows editing that cardholder.
        404: { description: "That is not the href of an access group membership." }
        409: *409CH
        4xx:
          description: |
            The operator does not have a privilege that allows editing that cardholder's access
            group memberships plus 'Modify access control' on the group.

  /api/cardholders/{id}/cards/{secondary_id}:
    parameters:
    - $ref: "#/components/parameters/id"
    - $ref: "#/components/parameters/secondary_id"

    delete:
      tags:
        - Cardholders

      summary: Remove a card from a cardholder
      description: |
        This call removes a card from a cardholder.

        You can find this URL in the [cardholder object](#definition-Cardholder-detail).  [Do not
        build it yourself](#topic-Forward-compatibility--HATEOAS-).

      responses: 
        200: { description: "Success." }
        204: { description: "Success." }
        403: { description: "The operator does not have a privilege that allows editing that cardholder." }
        404: { description: "That card is not on that cardholder." }
        409: *409CH
      

  /api/cardholders/{id}/competencies/{secondary_id}:
    parameters:
    - $ref: "#/components/parameters/id"
    - $ref: "#/components/parameters/secondary_id"
    delete:
      tags:
        - Cardholders

      summary: Remove a competency from a cardholder
      description: |
        This call removes a competency from a cardholder.

        You can find this URL in the [cardholder object](#definition-Cardholder-detail).  [Do not
        build it yourself](#topic-Forward-compatibility--HATEOAS-).

      responses: 
        200: { description: "Success." }
        204: { description: "Success." }
        403: { description: "The operator does not have a privilege that allows editing that cardholder." }
        404: { description: "That is not the href of a cardholder's competency." }

  /api/cardholders/{id}/competencies/{secondary_id}/credit:
    parameters:
    - $ref: "#/components/parameters/id"
    - $ref: "#/components/parameters/secondary_id"
    post:
      tags:
        - Cardholders

      summary: Change competency credit
      description: |
        This call increases or decreases a cardholder's competency credit.  It is an indivisible
        operation.

        It is reserved for the Pre-pay Car Parking feature.

      parameters:
        - name: "add"
          in: query
          required: true
          schema: {type: integer}
          description: "The amount to adjust the competency credit.  This can be positive or negative."
      responses: 
        200: { description: "Success.  Future versions will return feedback from the server." }
        204: { description: "Success." }
        403: { description: "The operator does not have a privilege that allows editing that cardholder." }
        404: { description: "The parameters are invalid." }

  /api/cardholders/{id}/elevator_groups/{secondary_id}:
    parameters:
    - $ref: "#/components/parameters/id"
    - $ref: "#/components/parameters/secondary_id"
    delete:
      tags:
        - Cardholders

      summary: Remove an elevator group from a cardholder
      description: |
        This call removes a default floor assignment and passenger types from a cardholder for one
        elevator group.

        You will find this URL in the `elevatorGroups` block of a [cardholder
        object](#definition-Cardholder-detail).  [Do not build it
        yourself](#topic-Forward-compatibility--HATEOAS-).

      responses:
        204:
          description:  Success.
        403:
          description: |
            Your operator does not have the necessary privilege to change this cardholder's elevator
            groups.
        404:
          description: |
            That is not the URL of a cardholder's elevator group.  You can take an href
            from the 'elevatorGroups' block of a cardholder detail.  The message in the results
            document will tell you more about the problem.

  /api/cardholders/{id}/lockers/{secondary_id}:
    parameters:
    - $ref: "#/components/parameters/id"
    - $ref: "#/components/parameters/secondary_id"
    delete:
      tags:
        - Cardholders

      summary: Remove a locker assignment
      description: |
        This call removes a locker assignment from a cardholder.  If the cardholder has no other
        assignments for this locker after this operation he or she will not be able to open it.

        You will find this URL in the `lockers` block of a [cardholder
        object](#definition-Cardholder-detail).  In the interest of forward compability, [do not
        build it yourself](#topic-Forward-compatibility--HATEOAS-).

      responses:
        204:
          description:  Success.
        404:
          description: |
            That is not the URL of a cardholder's locker assignment.  You can take an href from the
            'lockers' block of a cardholder detail, or the 'assignments' block of a locker or locker
            bank detail.  The message in the results document will tell you more about the problem.
        4xx: { description: "You do not have privileges for the operation." }

  /api/cardholders/{id}/operator_groups/{secondary_id}:
    parameters:
    - $ref: "#/components/parameters/id"
    - $ref: "#/components/parameters/secondary_id"
    delete:
      tags:
        - Cardholders
      summary: Remove an operator group membership

      description: |
        This call removes a cardholder's membership in an operator group.  Operator group
        memberships do not have start and end dates, so a cardholder can only have one membership in
        a given operator group.

        You can find this URL in the [cardholder object](#definition-Cardholder-detail).  In the
        interest of forward compability, [do not build it
        yourself](#topic-Forward-compatibility--HATEOAS-).

      responses: 
        204: 
          description: "Success."
        403:
          description: |
            The operator does not have a privilege that allows editing that cardholder's operator
            group memberships ('Modify operator group membership').
        404: { description: "That is not the href of an operator group membership." }
        409: *409CH

  /api/cardholders/{id}/roles/{secondary_id}:
    parameters:
    - $ref: "#/components/parameters/id"
    - $ref: "#/components/parameters/secondary_id"
    delete:
      tags:
        - Cardholders

      summary: Remove a relationship
      description: |
        This call severs a relationship between two cardholders.

        You can find the URL in the `relationships` block in the [cardholder
        object](#definition-Cardholder-detail) of the cardholder who has the relationship, not the
        cardholder who holds the role.  For example if you have a 'supervisor' role you would find
        the URL to delete by looking up the supervised cardholder, not the supervisor.

        In the interest of forward compability, [do not build the URL
        yourself](#topic-Forward-compatibility--HATEOAS-).

      responses: 
        204: 
          description: "Success."
        403: { description: "The operator does not have a privilege that allows editing that cardholder." }
        404: { description: "That is not the URL of a relationship.  Perhaps it is deleted already." }

  /api/cardholders/{id}/update_location:
    parameters:
    - $ref: "#/components/parameters/id"
    post:
      tags:
        - Cardholders

      summary: Change a cardholder's location
      description: |
        This call updates a cardholder's location (moves them) to a target access zone. Added in 8.20.

        [Do not code this URL](#topic-Forward-compatibility--HATEOAS-) into your application.  Take
        it from the 'updateLocation.href' field in a [cardholder
        response](#definition-Cardholder-detail).

        The POST expects a document which contains an href to the target access zone.  The
        recommended way of getting access zone hrefs is through an [access zones
        call](rest.html#operation--api-access_zones-update_cardholder_location-get) added in 8.20
        that returns you the access zones to which you are allowed to move cardholders, according to
        your operator privileges.

        You can also get access zone hrefs from the [items
        controller](events.html#operation--api-items-get).

        Note that to change a cardholder's location your REST operator will need the "Manage
        Cardholder Location" privilege in the division of the target access zone and "View
        Cardholder" on the cardholder itself.

        It is not possible to put a cardholder into "nowhere", also known as "outside the system".
        The only place you can move them is a new access zone.

      requestBody:
        description: |
          The body of the request must contain the href of the target access zone.
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CardholderUpdateLocationPOSTExample'
        required: true

      responses: 
        200: { description: "Success.  Future versions will return feedback from the server." }
        204: 
          description: "Success."
        400:
          description: |
            The cardholder ID or access zone href is invalid.
        403:
          description: |
            The operator does not have a privilege ('Manage Cardholder Location') that allows moving
            this cardholder to the target zone.

  /api/cardholders/{id}/edit:
    parameters:
    - $ref: "#/components/parameters/id"
    get:
      tags:
        - Cardholders
      summary:  Find out which fields you can edit

      description: |
        This tells you which fields your REST operator can edit based on its privileges.

        Gallagher uses this call for rapidly-evolving internal applications.  As such, its results
        are tuned to those applications and are subject to change.  Rather than relying on this
        call, we suggest that you simply give your REST operator the privileges it needs to access
        to everything it needs.

        Note that this method returns 400 if there are two
        PDFs in the system with the same name.  CC insists on unique names for items when you create
        them but you can end up with duplicates when you form a multiserver cluster out of
        standalone installations.  You should move on that, because having two PDFs with the same
        name will bewilder your operational staff.

      responses:
        200:
          description:  Success.
        4xx: { description: "The parameter is invalid or you do not have privileges for the operation." }

  

  /api/cardholders/changes:
    get:
      tags:
        - Cardholder changes
      summary:  Get changes
      description: |
        This returns cardholder changes matching your search criteria and a link for the next batch.

        The first time you call this it will return a link back to this call with a parameter
        marking the head of the change list.  ***There will not be any changes in the result set for
        your first call***.  When you later GET the link the server sent you, it will return the
        changes that occurred since, if there were any, and a new link.

        There will be no more than 1000 changes, or as many as you asked for using the `top` query
        parameter.

        When you are up to date with all the cardholder changes, the `results` array will be empty.
        When it comes time to check again, don't just re-use the same URL:  get a new one from the
        `next` block.  It can change even when there are no results.

        This is a polled interface:  it will return immediately, whether or not there are results.
        Therefore you should wait for a time between calls if the `results` array was empty.

        You can monitor changes to card data using this call, including serial numbers (MIFARE
        UIDs).  However you cannot monitor changes in the `lastSuccessfulAccessTime` or
        `lastSuccessfulAccessZone` fields because they are not attributes of a cardholder object:
        they are derivatives of his or her activity.  If you want to monitor a person's movements we
        advise subscribing to events.

        This is a polled interface:  it will return immediately, whether or not there are results.
        Therefore you should wait for a time between calls if the `results` array was empty.

        [Do not code this URL](#topic-Forward-compatibility--HATEOAS-) into your application.  Take
        it from the href field in the `features.cardholders.changes` section of `/api`.

        ### Efficiency tips when collecting cardholder changes

        - Filter for the kinds of changes you are after using the `filter` parameter.  If you are
          only interested in people's access group memberships, for example, add
          `filter=accessGroups` to your GET, and you will not be troubled with all the other kinds
          of changes that cardholders go through.

        - The default set of fields is large and expensive to compute.  Ease the load on the server,
          the network, and your client by asking for a smaller
          response.  For example if you are only interested in the current state of a cardholder's
          group memberships and do not care who made the change, or when, or what state the
          cardholder was in before use `fields=item,cardholder.accessGroups`.  You need `item` so
          you can tell which cardholder changed.  If you store your own identifier in a PDF you
          could drop `item` and add `cardholder.pdf_XXX`, where 'XXX' is the ID of your PDF.

        - Sleep for as long as you can between calls.

        - If you are only interested in changes to cardholders in certain divisions, only give your
          REST operator access to those divisions.  It will not see changes outside them.

      parameters:
      - $ref: "#/components/parameters/top"
      - $ref: "#/components/parameters/pos"
        description: Reserved for internal use.  You may see it in URLs you receive from the server, but you must never add it yourself.

      - name: "filter"
        in: query
        required: false
        schema:
          type: array
          default: ['defaults']
          items:
            type: string
            enum:  [href, id, firstName, lastName, shortName, description, authorised, lastSuccessfulAccessZone, division, notes, useExtendedAccessTime, personalDataFields, operatorLoginEnabled, operatorUsername, operatorPassword, operatorPasswordExpired, windowsLoginEnabled, windowsUsername, cards, accessGroups, competencies, notifications, relationships, lockers]
          

        description: |
          Limits the search results to the changes that affected these fields, and limits the
          `oldValues` and `newValues` blocks to these fields.  You can specify practically any of
          the fields in the [cardholder detail](#definition-Cardholder-detail).  You can also go
          into more detail; for example you can monitor a cardholder's cards' validity dates using
          `filter=cards.from,cards.until`.

          `filter` reduces the number of results; if you want to choose the blocks you receive in
          each result, use `fields`.

          If you do not supply a filter parameter it will use the same fields you get in a
          cardholder details page.  That is nearly everything the API has for a cardholder, but
          omits some seldom-used or expensive features such as card tracing and the large PIV
          fields.  If you want to monitor them you must list them here.  For example,
          `filter=defaults,cards.trace` will add the card trace flag to the usual filter.

          `personalDataFields` will filter for PDF changes, and will give you the
          personalDataDefinitions block plus the PDF values that changed.  You cannot filter for
          changes to a particular PDF:  you will need to do that in your client.

          Being able to monitor operator settings arrived in 8.50 and operator group memberships in
          8.60.

          Note that you cannot monitor changes in the `lastSuccessfulAccessTime` or
          `lastSuccessfulAccessZone` fields because they are not attributes of a cardholder object:
          they are derivatives of his or her activity.  If you want to monitor a person's movements
          we advise subscribing to events.

          If card changes are all you are interested in, and you do not want to hear about all the
          other changes that cardholders can experience, use `filter=cards`.

      - name: "fields"
        in: query
        required: false
        schema:
          type: array
          default: ['defaults']
          items:
            type: string
            enum:
              [href, operator, operator.href, operator.name, time, type, item, oldValues, newValues, cardholder, cardholder.* ]

        description: |
          Limits the blocks in the results.

          `fields` affects the blocks in each result; if you want to reduce the number of results,
          use `filter`.

          You can have finer-grained control of fields inside those blocks by listing their JSON
          paths.  For example, to see what the operator and affected cardholder's names are now, you
          could use `fields=operator.name,cardholder.firstName,cardholder.lastName`.

          The values you can list for the cardholder block are very similar to [these field
          names](#field-names-in-query-parameters).  Prefix each with `cardholder.` (since in this
          API they are all inside a block called `cardholder`).

          Separate values with commas and treat the strings as case sensitive.

          If you do not send this parameter the API will return all cardholder changes to a default
          set of fields.

          Use `personalDataFields` to monitor changes to PDF values on a cardholder.

      - name: "deadline"
        in: query
        required: false
        schema:
          default: 50
          type: integer
          minimum: 0
        description: |
          Sets the number of seconds after which the server will abort the query and return a 500.
          If that happens, you should try again later when the server (particularly the database
          server) is not so busy.

          Using this can be dangerous.  When the server aborts a query it discards all the work it
          did up to that point.  If you send the same query again later, with the same deadline, you
          may end up stuck in a loop, never making progress, and effectively DoSing your server.

          If your server is struggling, try reducing the size of each result set by using `top`.

          Added in 8.80.

      responses:
        200:
          description: Success.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CardholderChanges'
        4xx:
          description: |
            The site does not have the RESTCardholders licence.
        500:
          description: |
            The server was too busy to complete the request before the deadline.

##
##         Copyright Gallagher Group Ltd 2025 All Rights Reserved
##            THIS IS PROPRIETARY DOCUMENTATION SOURCE CODE OF
##                Gallagher Group Research and Development
##                          Hamilton, New Zealand
##

  /cardholders/{id}/cards/{secondary_id}/encoding_data/mifare_desfire:
    post:
      tags: [Cardholders]
      operationId: getDesfireEncodingData
      summary: Get encoding payload for a DESFire card
      description: |
        This returns the data you need to encode a Gallagher credential to a MIFARE DESFire card.
        
        POST the card's CSN (UID) and, if present on-card, the contents of the Gallagher Application
        Directory (CAD).  The response contains the DESFire applications, keys, files, and updated
        CAD bytes to write, and callback links for you to report the success of your encoding.

        **Encode applications in the order they are returned** so that the card remains usable if
        encoding fails part-way through.
      parameters:
        - $ref: '#/components/parameters/id'
        - $ref: '#/components/parameters/secondary_id'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/DesfireEncodingRequest'
            examples:
              request:
                value:
                  csn: "0x04A23F9C123456"
                  cad: "0x002B672081F4" 
      responses:
        "200":
          description: DESFire encoding data and callbacks
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DesfireEncodingResponse'
              examples:
                response:
                  value:
                    applications:
                      "0xF48120":
                        name: "gallagher"
                        keys:
                          "0": { name: "applicationKey",    data: "0xEE076105634A47AF70A0678CE86FE610" }
                          "1": { name: "uidDiscoveryKey",   data: "0x6C957D11151200A6492E27819D345DDA" }
                          "2": { name: "applicationReadKey", data: "0xF2428C4A0B3C8F81B7DB2E76370F73EA" }
                        keySettings1: "0x68"
                        keySettings2: "0x4C"
                        files:
                          "0": { data: "0xA396A32BA380A3375C695CD45C7F5CC8", accessRights: "0x0002" }
                          "1": { data: "0xA4F2276D46633FA29499B6BC781D8874", accessRights: "0x0002" }
                      "0xF4812F":
                        name: "gallagherApplicationDirectory"
                        keySettings1: "0x68"
                        keySettings2: "0x12"
                        keys:
                          applicationKey: { data: "0xbeef" }
                        files:
                          "0": { data: "0x002B672081F4", accessRights: "0x000E" }
                    callback:
                      encodeCompleted:
                        href: "https://localhost:8904/api/cardholders/123/cards/e3f8c7/encodeCompleted?token=a9f3b7"
                      encodeFailed:
                        href: "https://localhost:8904/api/cardholders/123/cards/e3f8c7/encodeFailed?token=a9f3b7"
        "400":
          description: |
            Possible reasons:
            - The request body is invalid.
            - There is no free application ID left on the card.
            - The card is not of an encodable type.  In API terms, its `credentialClass` needs to be `card`.

            The response body will contain an error message.
        "403":
          description: |
            Possible reasons:
            - Command Centre does not have a licence for the encoding API.
            - The operator lacks the necessary privilege.
            - Re-encoding is disabled for that card type and the card has already been encoded.
        "404": *404ENC

  /cardholders/{id}/cards/{secondary_id}/encoding_data/mifare_classic:
    post:
      tags: [Cardholders]
      operationId: getMifareClassicEncodingData
      summary: Get encoding payload for a Classic card
      description: |
        This returns the data you need to encode a Gallagher credential to a MIFARE Classic card.
        
        POST the card's CSN (UID) and card directory data (CAD/MAD) if present, plus any unavailable
        sectors.  The response contains the sectors and blocks to write, and callback links for you
        to report the success of your encoding.

        **Encode applications in the order they are returned** so that the card remains usable if
        encoding fails part-way through.

      parameters:
        - $ref: '#/components/parameters/id'
        - $ref: '#/components/parameters/secondary_id'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ClassicEncodingRequest'
            examples:
              request:
                value:
                  csn: "0x04A23F9C"
                  cad:
                    sector: 14
                    blocks:
                      "0": "0xadad"
                      "1": "0xafad"
                  mad:
                    blocks:
                      "1": "0x0ebd"
                      "2": "0x0816"
                  unavailableSectors: [2, 3, 4]
      responses:
        "200":
          description: Classic encoding data and callbacks
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ClassicEncodingResponse'
              examples:
                response:
                  value:
                    sectors:
                      "15":
                        name: "gallagher"
                        blocks:
                          "0": "0xA396A35AA380A31B5C695CA55C7F5CE4"
                          "1": "0x7777772E63617264617E2E636F6D2020"
                          "2": "0x00000000000000000000000000000000"
                          "3": "0x00000000000078778800000000000000"
                      "14":
                        name: "gallagherApplicationDirectory"
                        blocks:
                          "0": "0x1F34000102B670F00000000000000000"
                          "1": "0x00000000000000000000000000000000"
                          "2": "0x00000000000000000000000000000000"
                          "3": "0x00000000000078778800000000000000"
                      "0":
                        name: "mad"
                        blocks:
                          "1": "0xCD000000000000000000000000000000"
                          "2": "0x00000000000000000000000011481248"
                    callback:
                      encodeCompleted:
                        href: "https://localhost:8904/api/cardholders/123/cards/e3f8c7/encodeCompleted?token=a9f3b7"
                      encodeFailed:
                        href: "https://localhost:8904/api/cardholders/123/cards/e3f8c7/encodeFailed?token=a9f3b7"
        "400":
          description: |
            Possible reasons:
            - The request body was invalid.
            - There are no free sectors left on the card.
            - The card is not of an encodable type.  In API terms, its `credentialClass` needs to be `card`.

        "403":
          description: |
            Possible reasons:
            - Command Centre does not have a licence for the encoding API.
            - The operator lacks the necessary privilege.
            - Re-encoding is disabled for that card type and the card has already been encoded.
        "404": *404ENC

  /cardholders/{id}/cards/{secondary_id}/encodeCompleted:
    post:
      tags: [Cardholders]
      operationId: notifyEncodeCompleted
      summary: Notify Command Centre that encoding succeeded
      description: Notify Command Centre that encoding succeeded for the given credential.
      parameters:
        - $ref: '#/components/parameters/id'
        - $ref: '#/components/parameters/secondary_id'
        - $ref: '#/components/parameters/token'
      responses:
        "200":
          description: OK
        "400":
          description: Bad Request - Token is missing or not recognized
        "403":
          description: The site does not have a licence for the Encoding API.
        "404": *404ENC
        "410":
          description: Gone - Callback token has expired or already been used

  /cardholders/{id}/cards/{secondary_id}/encodeFailed:
    post:
      tags: [Cardholders]
      operationId: notifyEncodeFailed
      summary: Notify Command Centre that encoding failed
      description: |
        Notify Command Centre that encoding failed for the given credential. Optionally include an
        error message.
      parameters:
        - $ref: '#/components/parameters/id'
        - $ref: '#/components/parameters/secondary_id'
        - $ref: '#/components/parameters/token'
      requestBody:
        required: false
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ErrorMessage'
            examples:
              example:
                value:
                  message: "Insert any error message here."
      responses:
        "200":
          description: OK
        "400":
          description: Token is missing or not recognized, or invalid request body.
        "403":
          description: The site does not have a licence for the Encoding API.
        "404": *404ENC
        "410":
          description: Callback token has expired or already been used.

security:
  - API_key: []

servers:
  - url: https://localhost:8904

tags:

- name: "Cardholders"
  description: |
    A cardholder is a user account.

    These methods give you read and write access to the cardholder data in the Command
    Centre database.  You can download cardholders, create them, search them by name or
    Personal Data Field (PDF) value, and work on them as you would in the interactive
    clients.

    The first use case below introduces the main entry point.  It is a paginated search interface
    that gives you basic data for any number of cardholders.  You won't receive many fields by
    default, but you can ask for more using the `fields` query parameter.

    A field called 'href' serves both as a unique identifier for the cardholder and the location of
    what we call his or her _details_ page.  You can submit an HTTP GET to that href to retrieve the
    entire cardholder record, or an HTTP PATCH to update it, or an HTTP DELETE to remove it.  Be
    careful:  there is no coming back from deleting a cardholder.

    ### Use cases

    #### Searching for cardholders by name
    1. `GET /api`.
    2. Follow the link at `features.cardholders.cardholders.href`
       [](#operation--api-cardholders-get), appending a search term to narrow the results and the
       'fields' parameter to add the fields you need.
    3. Process the results, following the `next` link until there isn't one.

    #### Downloading all cardholders 
    1. `GET /api`

    2. Follow the link at `features.cardholders.cardholders.href`
       [](#operation--api-cardholders-get).  This is effectively a cardholder search with no
       filters.  You should add `sort` and `top` query parameters to sort by ID and increase the
       number of cardholders per page:  see the efficiency tips!

    3. Process the bundle of cardholders in the result.
    4. Follow the link at `next.href` if there is one, and repeat.

    #### Synchronising a user directory

    This is a common use case, described in the section on [Cardholder
    changes](#tag-Cardholder-changes).  It shows how to:

    1. Get a bookmark at the head of the queue of cardholder changes.
    2. Do a one-off sync of all cardholders.
    3. Loop to stay up to date, starting with the bookmark.

    That is how Gallagher's cardholder-synchronising integrations work.

    #### Searching for cardholders by Personal Data Field value

    Say you want to find a cardholder with a particular employee ID, and Command Centre is
    holding that in a personal data field called "employee_ID".

    First, reconsider, and look at the 'Synchronising a user directory' use case above.  If you are
    going to be doing this for many cardholders, GETting cardholders in bulk and filtering out the
    interesting ones client-side is more efficient than a large number of unique PDF searches.  You
    don't have to get all cardholders; you could get all cardholders in one division, or all
    cardholders with a non-blank value for your PDF (shown below), or a combination.  It will be
    quicker than a sequence of searches that return one cardholder each.

    Before you can start a cardholder search, you must find the PDF's identifier.

    1. `GET /api`.

    2. v8.10 or later:  follow the link at `features.personalDataFields.personalDataFields.href`
       [](#operation--api-personal_data_fields-get), appending the query `name="employee_id"`.
       This will return every PDF in the system with that name.  There will be more than one, in
       rare cases.

    2. Earlier versions:  follow the link at `features.items.items.href`
       [](events.html#operation--api-items-get), appending the query `name="employee_id"` (after a
       `?` or `&`, of course).  This will return every item in the system with that name.  Pick the
       one with a type name of 'Personal Data Field'.  Or you could append `type=33` to the item
       search:  you will only be shown PDFs.

    3. Note the ID of the item.  It will be a short alphanumeric.

    Case does not matter when searching by name but remember the quotes:  Command Centre will
    perform a substring match if you omit them, which is vastly slower and (for the example above)
    return you the PDFs 'previous_employee_ID' and 'employee_ID_allocated_flag', if you have
    PDFs with those names.

    Now you can use that PDF ID in a cardholder search.

    1. Recall the JSON object you received from `GET /api`.
    2. Follow the link at `features.cardholders.cardholders.href`
       [](#operation--api-cardholders-get), adding a query separator and
       `pdf_<your_pdf_id>=<your_pdf_value>`, without the angle brackets.

    The results will only include cardholders who have *\<your_pdf_value>* as a substring of
    the Personal Data Field with ID *\<your_pdf_id>*.  Again, the search is
    case-insensitive and you should bookend *\<your_pdf_value>* with quotes if you want to anchor it at
    each end.  In our example we would `GET /api/cardholders?pdf_345="EID8888"`.

    Use a percent sign `%` for *\<your_pdf_value>* if you want to see all cardholders who have a
    non-blank value for that PDF.

    The server will reply with a default set of fields for your cardholder.  If they are not what
    you'd like, you can use the `fields` query parameter to change them.

    See the [cardholder GET](#operation--api-cardholders-get) for more.

    #### Creating a cardholder
    1. `GET /api`.
    2. Use the link at `features.accessGroups.accessGroups.href` to find the hrefs of access groups
    you wish to add your new cardholder to.

    3. Do the same for the competencies, relationships (`roles`), lockers, PDF definitions, and
    cards/credentials (`cardTypes`) that your new cardholder needs, using other URLs in the
    'features' section of `/api`.  In v8.10, the card types that your operator has the privilege to
    assign are at a new URL given in the field `features.cardTypes.assign.href`
    [](#operation--api-card_types-assign-get).

    4. Compose a JSON body using [this example](#definition-Cardholder-POST-example) and
    [this detail](#definition-Cardholder-detail), then
    [POST](#operation--api-cardholders-post) it to the href at
    `features.cardholders.cardholders.href` [](#operation--api-cardholders-post) on the `/api` page.
    
    #### Modifying a cardholder
    1. Find your cardholder using one of the processes above.
    2. If you need the current values before you update them, use the `fields` parameter to add
    fields (such as accessGroups, cards, or competencies) to the search results.

    3. [PATCH](#operation--api-cardholders--id--patch) the cardholder's href with a
    document describing the additions, deletions, and modifications you wish to make to
    the cardholder and his or her associations.

    In its simplest form, your document could be a collection of key/value pairs much the same as
    you receive from a GET to the same href.  [More complex
    forms](#definition-Cardholder-PATCH-example) allow adding, modifying, and removing cards,
    competencies, group membership, PDFs, and relationships.  Three examples follow.

    #### Removing a cardholder from groups

    1. Find your cardholder using one of the processes above.
    2. Follow the link to their details page or add `fields=accessGroups` to the search.  That will
       show all their access group memberships.

    3. [PATCH](#operation--api-cardholders--id--patch) the cardholder with the hrefs of the
       memberships you want to delete in an array called `remove` inside a block called
       `accessGroups`.

    The [access groups](#tag-Access-groups) section describes what to do when you want to
    start with a group and remove several cardholders from it.

    #### Removing all group memberships, competencies, relationships, cards, or lockers

    This shows how you could remove a cardholder from all his or her access groups, but you could
    just as simply apply the process to other fields that come back as arrays, such as competencies,
    relationships, operator groups, cards, and lockers.

    1. GET your cardholder's details page, or search with `accessGroups` in the field list.  Either
    way, you will receive all their access group memberships.
    2. Take the array at `accessGroups`, rename it to `remove`, and put it in object called
    `accessGroups` at the root level of a [JSON object](#definition-Cardholder-PATCH-example).
    3. [PATCH](#operation--api-cardholders--id--patch) the cardholder with that JSON object.  That
    will remove the cardholder from all the groups that came back in the GET.

    #### Assigning a new card to a cardholder

    1. `GET /api`.
    2. Follow the link at `features.cardTypes.cardTypes.href` [](#operation--api-card_types-get) to
       find the href for the new card's type.
    3. If you want to create a card in a state other than the default, get the state from the same page.
    4. Find the href for the cardholder using one of the search methods above.
    5. Optional:  follow the link at `edit.href` on the cardholder page.  If there is a link at
       `update.href`, your REST client has permission to modify the cardholder.
    4. PATCH the cardholder's href according to the [cardholder patch
       schema](#definition-Cardholder-PATCH-example).

    #### Deleting a cardholder's PDF value
    1. Find the URL of your cardholder using one of the processes above.
    4. [PATCH](#operation--api-cardholders--id--patch) your cardholder with this in the body:
      `{ "@name_of_PDF": null }`
    
    
    #### Deleting a cardholder
    1. Find your cardholder using one of the processes above.
    2. Send an HTTP DELETE to the cardholder's href.

    #### Updating a cardholder's location
    1. Find the href of your target access zone using the link at
       `features.cardholders.updateLocationAccessZones`
       [](rest.html#operation--api-access_zones-update_cardholder_location-get) in the results of
       `GET /api`.
    1. Find your cardholder using one of the processes above.  If you are using
       [search](#operation--api-cardholders-get), add `updateLocation` to the `fields` parameter to
       save you having to GET their details page later.
    2. Send an [HTTP POST](#operation--api-cardholders--id--update_location-post) to that
       cardholder's `updateLocation.href` link.

    #### Finding which access zones and doors a cardholder can access
    1. GET your cardholder's details page, or search cardholders with `accessGroups` in the field
    list.  Either way, you will receive all their access group memberships.
    2. Iterate through all the access groups looking into their `access` blocks for access zones and
    schedules.  Recurse up the access group hierarchy by following each group's `parent.href`.

    Now you have the cardholder's access zones.  If you want doors:

    3. For each access zone, GET its href and look in its `doors` block.

    #### Finding recently-created cardholders

    Informing you when Command Centre creates cardholders is a function of the [Cardholder
    changes](#tag-Cardholder-changes) call, described there.

    However for that to work you need to make API calls before and after the cardholders are
    created.  If they already exist, a workaround is to get a page of cardholders sorted by
    database ID _descending_ using `sort=-id&top=10`.  Change the ten to the number of cardholders
    you'd like, obviously.  Because Command Centre allocates database IDs to new items in
    increasing order, the first page you get will be the most-recently created cardholders.  This
    is not suitable for use in a production system!  Use the cardholder changes call instead.

    ### Field names in query parameters

    The cardholder [search](#operation--api-cardholders-get) and
    [details](#operation--api-cardholders--id--get) operations' `fields` parameter and the [change
    tracking](#operation--api-cardholders-changes-get) operation's `fields` and `filter` parameters
    take a list of field names.  Other sections of this document describe how those parameters
    affect the API calls, but their format is the same so this section will cover it once.

    You can form the name of a field by joining the components of its JSON path with dots.  Fields
    at the root level of the cardholder object, such as `firstName` and `@emailAddress` (a PDF),
    have just one component.  Fields that are one level down, such as `accessGroups.status`, have
    two.

    Treat the string matches as case sensitive:  use `lastName` rather than `lastname`.

    The string must not contain any spaces.  Just alphanumerics, underscores, commas, and dots.

    To serve as examples, this is the list you can choose from in 8.30:

    `href`, `id`, `firstName`, `lastName`, `shortName`, `description`, `authorised`,
    `lastSuccessfulAccessTime`, `lastSuccessfulAccessZone`, `division`,
    `personalDataFields`, `cards`, `accessGroups`, `competencies`, `notes`, `notifications`,
    `relationships`, `lockers`,
    `cards.href`, `cards.number`, `cards.from`, `cards.until`, `cards.cardSerialNumber`, `cards.type`,
    `cards.status`, `cards.invitation`, `cards.issueLevel`, `cards.pivData`,
    `cards.pivData.chuid`, `cards.pivData.pivStatus`, `cards.pivData.lastCheckTime`,
    `cards.pivData.chuid.hash`, `cards.pivData.chuid.fascn`, `cards.pivData.chuid.duns`,
    `cards.pivData.chuid.orgIdentifier`,
    `cards.invitation.href`, `cards.invitation.singleFactorOnly`, `cards.invitation.email`,
    `cards.invitation.mobile`,
    `notifications.enabled`, `notifications.from`, `notifications.until`,
    `accessGroups.href`, `accessGroups.accessGroup`, `accessGroups.from`,
    `accessGroups.until`, `accessGroups.status`,
    `relationships.href`, `relationships.cardholder`, `relationships.role`,
    `lockers.href`, `lockers.locker`, `lockers.from`, `lockers.until`

    Later versions of Command Centre added many more.  See the
    [details](#operation--api-cardholders--id--get) operation for the complete list of cardholder
    fields.

    A special value `default` applies a default set of fields that varies with the call you're
    making.

    `personalDataFields` is also special.  It will give you the personalDataDefinitions block plus
    all the PDF values at the root level with their names preceded by '@'-signs.

    ### Licensing

    All of the API calls described here are available with the RESTCardholders licence, with the
    following exceptions and notes:

      * Visitor management calls need both RESTCardholders and VisitorManagement.

      * Creating, modifying, and deleting cardholders' connections to competencies requires the
        RESTConfiguration licence.

      * Creating, modifying, and deleting competency items requires the RESTConfiguration licence.

      * Managing access group _memberships_ is enabled by the RESTCardholders licence but managing
        access group items, card types, personal data definitions, and roles will require the
        RESTConfiguration licence.  These features are coming soon.

      * Lockers and locker banks are also available with the RESTStatus licence, and a subset of
        their fields (enough to allow overriding them) are available with the RESTOverrides licence.

    The server will return a 403 if you attempt an operation for which the server is not licensed.

    ### Versions

    The body of this document clearly indicates when recent features arrived in the API so that
    readers with older versions of Command Centre know not to expect them.
    
    #### Cardholder API changes on the roadmap

    * You will be able to create, delete, and change the the basic configuration of
      roles, PDFs, and card types.

    * POTENTIALLY BREAKING CHANGE:  searching for cardholders using `pdf_xxx=""` or `pdf_xxx=`
      currently returns no cardholders.  That is neither useful nor desired.  Instead, a future
      version of Command Centre will return cardholders with a blank value for that PDF.

    * POTENTIALLY BREAKING CHANGE:  the API route that lets you modify a cardholder by PATCH also
      works if you send it a POST.  It should not, because POSTs create things, not modify them.
      The fix will break clients that rely on this.  There should be none, since the POST was not
      documented.

    * POTENTIALLY BREAKING CHANGE:  in future, PATCH methods will return "200 Success" instead of
      "204 No Content" and may contain the object you modified plus a message from the API giving
      you feedback on your request.  Please be aware that all 200-level response codes mean success,
      not just the ones old versions have been sending you.

    * A cardholder's visits and escort.

    * "Revealable" access levels on PDFs.

    * Current versions of the API only show a PDF on a cardholder if he or she has a value for that
      PDF.  That makes it difficult to find out which PDFs a cardholder _could_ have, so a future
      version will allow you to ask for all of them with `fields=allPdfs`.

    * You will be able to request the competencies that your operator has the permission to assign.
      That is determined by privileges, a competency setting, and an operator group setting.
      Current versions let you request the competencies that your operator has the permission to
      view, which is a larger set determined by privileges alone, and not suitable for interactive
      REST clients.

- name: Cardholder changes
  description: |
    This feature keeps you up to date with cardholders by telling you the changes that happened
    since the last time you called.  It works for creations, modifications, and deletions coming
    from all
    sources, including Gallagher's clients, EDI, Active Directory, remote servers, and the other
    cardholder APIs.

    It first appeared in version 8.30.

    Because it also reports changes made through the REST API, it will tell you about your own
    changes.  If you are using this API both for managing cardholders and as a source of truth, you
    should be careful not to get yourself into a loop.

    This API was built to synchronise a second system with Command Centre's cardholder directory,
    not for auditing or reporting.  You will find the [events API](eventsApi.yaml) quicker and more
    flexible for those tasks.

    ### Recommended use

    1. First, get a bookmark at the end of Command Centre's list of changes as follows:
      
        1a. `GET /api`

        1b. Follow the link at `features.cardholders.changes` [](#operation--api-cardholders-changes-get).

        1c. Take note of the href in the `next` block.  This is your bookmark.  Later on you will
        ask for all the changes that happen after this point.

    1. If you are filling a user directory from Command Centre, download all cardholders using [this
    advice](#downloading-all-cardholders).  Here is a reminder:

        2a. Using the results of `GET /api` again, follow the link at
          `features.cardholders.cardholders` [](#operation--api-cardholders-get), adding query
          parameters `top=1000` and `sort=id`.

        2b. Process those cardholders (probably 1000) and follow the `next.href` link in
          a loop until you have extracted all of them.

    1. This is the start of your update loop.  The first time through, to catch the changes that
       came in during the big download you did in step two, use the href that you got in step one.
       Simply GET it.

    1. If the `results` array you get back is empty you are up to date and you have nothing to do.
       Sleep for a time before your next poll, to avoid a tight loop and ease the load on your
       database.  When it comes time to poll again, do not be tempted to resubmit the same request:
       the URL to use sometimes changes even when there are no results, so always get it from
       `next.href`.

    1. If the `results` array is not empty it will contain the first changes that happened after
    your previous call.  The sections below will help you process them.

    1. Restart your polling loop using the link in `next.href`.

    ### Use case:  detecting when cardholders are created.

    The first thing you need to do is get a link from the changes API call _before_ the cardholders
    you are interested in are created in Command Centre.  If you didn't do that, there is a
    workaround described in the cardholder use cases, but it is not suitable for production.

    When you call this API the second time you will receive all changes made to cardholders since
    the previous call.  To find the new cardholders, discard all the results that do not have
    `type=add`.

    Since you are only interested in new data, you can optimise the call a little with
    `fields=newValues`, which will remove the fields you do not need.

    ### Notes

    - The API will not notify changes to any fields that you cannot see in the cardholders API, such
      as user codes, passwords, card PINs, car park assignments, biometric credentials, and (in
      versions before 8.50) operator settings.

    - There is a known issue in 8.50 preventing operator group membership changes coming out of this
      API.  It was fixed in 8.60.  Changes to the other five operator settings work correctly in
      8.50.

    - The API will return the pre-change values of some fields, but not those that require a lot of
      storage such as image PDFs and PIV certificates.  Command Centre does not hang on to them
      after they change.

